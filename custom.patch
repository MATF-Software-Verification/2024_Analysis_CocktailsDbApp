diff --git a/.idea/AndroidProjectSystem.xml b/.idea/AndroidProjectSystem.xml
new file mode 100644
index 0000000..4a53bee
--- /dev/null
+++ b/.idea/AndroidProjectSystem.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AndroidProjectSystem">
+    <option name="providerId" value="com.android.tools.idea.GradleProjectSystem" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/androidTestResultsUserPreferences.xml b/.idea/androidTestResultsUserPreferences.xml
new file mode 100644
index 0000000..130d3b7
--- /dev/null
+++ b/.idea/androidTestResultsUserPreferences.xml
@@ -0,0 +1,373 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AndroidTestResultsUserPreferences">
+    <option name="androidTestResultsTableState">
+      <map>
+        <entry key="-2012355643">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-1529066837">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-1193614718">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-1157368542">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-1134845849">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-1086194259">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-906764922">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-666826855">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-525342597">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-482857883">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="-363782155">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="69394749">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="99392152">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="126554799">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="190" />
+                  <entry key="Pixel_6" value="219" />
+                  <entry key="Tests" value="459" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="218797004">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="261669756">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="642752266">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="750120520">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="796444724">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="1269125170">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="1270377560">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="1760739386">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="2021800640">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="2044732293">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="2108288888">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="2115119720">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="2130176139">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+        <entry key="2130176182">
+          <value>
+            <AndroidTestResultsTableState>
+              <option name="preferredColumnWidths">
+                <map>
+                  <entry key="Duration" value="90" />
+                  <entry key="Pixel_6" value="120" />
+                  <entry key="Tests" value="360" />
+                </map>
+              </option>
+            </AndroidTestResultsTableState>
+          </value>
+        </entry>
+      </map>
+    </option>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/codeStyles/Project.xml b/.idea/codeStyles/Project.xml
new file mode 100644
index 0000000..7643783
--- /dev/null
+++ b/.idea/codeStyles/Project.xml
@@ -0,0 +1,123 @@
+<component name="ProjectCodeStyleConfiguration">
+  <code_scheme name="Project" version="173">
+    <JetCodeStyleSettings>
+      <option name="CODE_STYLE_DEFAULTS" value="KOTLIN_OFFICIAL" />
+    </JetCodeStyleSettings>
+    <codeStyleSettings language="XML">
+      <option name="FORCE_REARRANGE_MODE" value="1" />
+      <indentOptions>
+        <option name="CONTINUATION_INDENT_SIZE" value="4" />
+      </indentOptions>
+      <arrangement>
+        <rules>
+          <section>
+            <rule>
+              <match>
+                <AND>
+                  <NAME>xmlns:android</NAME>
+                  <XML_ATTRIBUTE />
+                  <XML_NAMESPACE>^$</XML_NAMESPACE>
+                </AND>
+              </match>
+            </rule>
+          </section>
+          <section>
+            <rule>
+              <match>
+                <AND>
+                  <NAME>xmlns:.*</NAME>
+                  <XML_ATTRIBUTE />
+                  <XML_NAMESPACE>^$</XML_NAMESPACE>
+                </AND>
+              </match>
+              <order>BY_NAME</order>
+            </rule>
+          </section>
+          <section>
+            <rule>
+              <match>
+                <AND>
+                  <NAME>.*:id</NAME>
+                  <XML_ATTRIBUTE />
+                  <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                </AND>
+              </match>
+            </rule>
+          </section>
+          <section>
+            <rule>
+              <match>
+                <AND>
+                  <NAME>.*:name</NAME>
+                  <XML_ATTRIBUTE />
+                  <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                </AND>
+              </match>
+            </rule>
+          </section>
+          <section>
+            <rule>
+              <match>
+                <AND>
+                  <NAME>name</NAME>
+                  <XML_ATTRIBUTE />
+                  <XML_NAMESPACE>^$</XML_NAMESPACE>
+                </AND>
+              </match>
+            </rule>
+          </section>
+          <section>
+            <rule>
+              <match>
+                <AND>
+                  <NAME>style</NAME>
+                  <XML_ATTRIBUTE />
+                  <XML_NAMESPACE>^$</XML_NAMESPACE>
+                </AND>
+              </match>
+            </rule>
+          </section>
+          <section>
+            <rule>
+              <match>
+                <AND>
+                  <NAME>.*</NAME>
+                  <XML_ATTRIBUTE />
+                  <XML_NAMESPACE>^$</XML_NAMESPACE>
+                </AND>
+              </match>
+              <order>BY_NAME</order>
+            </rule>
+          </section>
+          <section>
+            <rule>
+              <match>
+                <AND>
+                  <NAME>.*</NAME>
+                  <XML_ATTRIBUTE />
+                  <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                </AND>
+              </match>
+              <order>ANDROID_ATTRIBUTE_ORDER</order>
+            </rule>
+          </section>
+          <section>
+            <rule>
+              <match>
+                <AND>
+                  <NAME>.*</NAME>
+                  <XML_ATTRIBUTE />
+                  <XML_NAMESPACE>.*</XML_NAMESPACE>
+                </AND>
+              </match>
+              <order>BY_NAME</order>
+            </rule>
+          </section>
+        </rules>
+      </arrangement>
+    </codeStyleSettings>
+    <codeStyleSettings language="kotlin">
+      <option name="CODE_STYLE_DEFAULTS" value="KOTLIN_OFFICIAL" />
+    </codeStyleSettings>
+  </code_scheme>
+</component>
\ No newline at end of file
diff --git a/.idea/codeStyles/codeStyleConfig.xml b/.idea/codeStyles/codeStyleConfig.xml
new file mode 100644
index 0000000..79ee123
--- /dev/null
+++ b/.idea/codeStyles/codeStyleConfig.xml
@@ -0,0 +1,5 @@
+<component name="ProjectCodeStyleConfiguration">
+  <state>
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+  </state>
+</component>
\ No newline at end of file
diff --git a/.idea/deploymentTargetSelector.xml b/.idea/deploymentTargetSelector.xml
new file mode 100644
index 0000000..e95fd81
--- /dev/null
+++ b/.idea/deploymentTargetSelector.xml
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="deploymentTargetSelector">
+    <selectionStates>
+      <SelectionState runConfigName="app">
+        <option name="selectionMode" value="DROPDOWN" />
+        <DropdownSelection timestamp="2025-10-19T14:33:29.874316Z">
+          <Target type="DEFAULT_BOOT">
+            <handle>
+              <DeviceId pluginId="LocalEmulator" identifier="path=/Users/stefanvucan/.android/avd/Pixel_6.avd" />
+            </handle>
+          </Target>
+        </DropdownSelection>
+        <DialogSelection />
+      </SelectionState>
+      <SelectionState runConfigName="testLoginWithInvalidCredentials()">
+        <option name="selectionMode" value="DROPDOWN" />
+      </SelectionState>
+      <SelectionState runConfigName="testCocktailsBottomNavigation()">
+        <option name="selectionMode" value="DROPDOWN" />
+      </SelectionState>
+      <SelectionState runConfigName="testAppFlow()">
+        <option name="selectionMode" value="DROPDOWN" />
+      </SelectionState>
+      <SelectionState runConfigName="testCocktailsBottomNavigation() (1)">
+        <option name="selectionMode" value="DROPDOWN" />
+      </SelectionState>
+      <SelectionState runConfigName="DatabaseTests">
+        <option name="selectionMode" value="DROPDOWN" />
+      </SelectionState>
+    </selectionStates>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/deviceManager.xml b/.idea/deviceManager.xml
new file mode 100644
index 0000000..91f9558
--- /dev/null
+++ b/.idea/deviceManager.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="DeviceTable">
+    <option name="columnSorters">
+      <list>
+        <ColumnSorterState>
+          <option name="column" value="Name" />
+          <option name="order" value="ASCENDING" />
+        </ColumnSorterState>
+      </list>
+    </option>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/gradle.xml b/.idea/gradle.xml
index 8da2fd3..17f3afa 100644
--- a/.idea/gradle.xml
+++ b/.idea/gradle.xml
@@ -1,13 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="GradleMigrationSettings" migrationVersion="1" />
   <component name="GradleSettings">
     <option name="linkedExternalProjectsSettings">
       <GradleProjectSettings>
-        <option name="testRunner" value="GRADLE" />
-        <option name="distributionType" value="DEFAULT_WRAPPED" />
+        <option name="testRunner" value="CHOOSE_PER_TEST" />
         <option name="externalProjectPath" value="$PROJECT_DIR$" />
-        <option name="gradleHome" value="/usr/local/Cellar/gradle/8.0.2/libexec" />
-        <option name="gradleJvm" value="jbr-17" />
+        <option name="gradleJvm" value="homebrew-17" />
         <option name="modules">
           <set>
             <option value="$PROJECT_DIR$" />
diff --git a/.idea/migrations.xml b/.idea/migrations.xml
new file mode 100644
index 0000000..f8051a6
--- /dev/null
+++ b/.idea/migrations.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectMigrations">
+    <option name="MigrateToGradleLocalJavaHome">
+      <set>
+        <option value="$PROJECT_DIR$" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
index 0ad17cb..f3aad98 100644
--- a/.idea/misc.xml
+++ b/.idea/misc.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ExternalStorageConfigurationManager" enabled="true" />
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="jbr-17" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="homebrew-17" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
   <component name="ProjectType">
diff --git a/.idea/runConfigurations.xml b/.idea/runConfigurations.xml
new file mode 100644
index 0000000..16660f1
--- /dev/null
+++ b/.idea/runConfigurations.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RunConfigurationProducerService">
+    <option name="ignoredProducers">
+      <set>
+        <option value="com.intellij.execution.junit.AbstractAllInDirectoryConfigurationProducer" />
+        <option value="com.intellij.execution.junit.AllInPackageConfigurationProducer" />
+        <option value="com.intellij.execution.junit.PatternConfigurationProducer" />
+        <option value="com.intellij.execution.junit.TestInClassConfigurationProducer" />
+        <option value="com.intellij.execution.junit.UniqueIdConfigurationProducer" />
+        <option value="com.intellij.execution.junit.testDiscovery.JUnitTestDiscoveryConfigurationProducer" />
+        <option value="org.jetbrains.kotlin.idea.junit.KotlinJUnitRunConfigurationProducer" />
+        <option value="org.jetbrains.kotlin.idea.junit.KotlinPatternConfigurationProducer" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
index a59ffb2..a5a8212 100644
--- a/app/build.gradle.kts
+++ b/app/build.gradle.kts
@@ -1,11 +1,20 @@
+import com.android.build.gradle.internal.coverage.JacocoReportTask
+
 plugins {
     alias(libs.plugins.android.application)
     alias(libs.plugins.android.kotlin)
     alias(libs.plugins.ksp)
     alias(libs.plugins.google.dagger.hilt)
     alias(libs.plugins.androidx.navigation.safeargs)
+    jacoco
+    id("org.jetbrains.kotlinx.kover")
+}
+
+jacoco {
+    toolVersion = "0.8.12"
 }
 
+
 android {
     namespace = "com.example.cocktailsdbapp"
     compileSdk = 34
@@ -28,6 +37,10 @@ android {
                 "proguard-rules.pro"
             )
         }
+        debug {
+            enableAndroidTestCoverage = true
+            enableUnitTestCoverage = true
+        }
     }
     buildFeatures {
         viewBinding = true
@@ -41,6 +54,7 @@ android {
     }
 }
 
+
 dependencies {
 
     implementation(libs.androidx.ktx)
@@ -49,9 +63,16 @@ dependencies {
     implementation(libs.androidx.constraint.layout)
     implementation(libs.androidx.navigation.fragment.ktx)
     implementation(libs.androidx.navigation.ui.ktx)
+    implementation(libs.androidx.navigation.testing.android)
+    implementation(libs.androidx.espresso.contrib)
     testImplementation(libs.junit)
+    testImplementation("io.mockk:mockk:1.13.8")
+    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
+    testImplementation("androidx.arch.core:core-testing:2.2.0")
+    androidTestImplementation("androidx.fragment:fragment-testing:1.6.2")
     androidTestImplementation(libs.androidx.junit)
     androidTestImplementation(libs.androidx.espresso.core)
+    androidTestImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
 
     // Hilt
     implementation(libs.hilt.android)
@@ -71,5 +92,13 @@ dependencies {
     ksp (libs.androidx.room.compiler)
 
     implementation(libs.expandableTextView)
+    testImplementation(kotlin("test"))
 
 }
+
+tasks.withType(Test::class) {
+    configure<JacocoTaskExtension> {
+        isIncludeNoLocationClasses = true
+        excludes = listOf("jdk.internal.*")
+    }
+}
\ No newline at end of file
diff --git a/app/src/androidTest/java/com/example/cocktailsdbapp/database/DatabaseTests.kt b/app/src/androidTest/java/com/example/cocktailsdbapp/database/DatabaseTests.kt
new file mode 100644
index 0000000..837e2ba
--- /dev/null
+++ b/app/src/androidTest/java/com/example/cocktailsdbapp/database/DatabaseTests.kt
@@ -0,0 +1,124 @@
+package com.example.cocktailsdbapp.database
+
+import androidx.room.Room
+import androidx.test.core.app.ApplicationProvider
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import junit.framework.TestCase.assertEquals
+import junit.framework.TestCase.assertNotNull
+import junit.framework.TestCase.assertNull
+import kotlinx.coroutines.runBlocking
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * Android Instrumentation Tests for Room Database
+ * Tests database operations on actual Android environment
+ */
+@RunWith(AndroidJUnit4::class)
+@SmallTest
+class DatabaseTests {
+
+    private lateinit var database: AppDatabase
+    private lateinit var cocktailDao: CocktailDao
+
+    @Before
+    fun createDb() {
+        database = Room.inMemoryDatabaseBuilder(
+            ApplicationProvider.getApplicationContext(),
+            AppDatabase::class.java
+        ).allowMainThreadQueries().build()
+        cocktailDao = database.cocktailDao()
+    }
+
+    @After
+    fun closeDb() {
+        database.close()
+    }
+
+    @Test
+    fun testInsertAndGetCocktail() = runBlocking {
+        // Given
+        val cocktail = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        val userEmail = "test@example.com"
+
+        // When
+        cocktailDao.insertCocktail(cocktail)
+        cocktailDao.insertFavorite(RoomFavorite(userEmail, cocktail.idDrink))
+        val retrieved = cocktailDao.findFavoriteCocktail(userEmail, cocktail.idDrink)
+
+        // Then
+        assertNotNull(retrieved)
+        assertEquals(cocktail.strDrink, retrieved?.strDrink)
+        assertEquals(cocktail.strDrinkThumb, retrieved?.strDrinkThumb)
+        assertEquals(cocktail.idDrink, retrieved?.idDrink)
+    }
+
+    @Test
+    fun testDeleteCocktail() = runBlocking {
+        // Given
+        val cocktail = RoomCocktail("Margarita", "margarita.jpg", "11008")
+        val userEmail = "test@example.com"
+
+        cocktailDao.insertCocktail(cocktail)
+        cocktailDao.insertFavorite(RoomFavorite(userEmail, cocktail.idDrink))
+
+        // When
+        cocktailDao.removeFavorite(userEmail, cocktail.idDrink)
+        val retrieved = cocktailDao.findFavoriteCocktail(userEmail, cocktail.idDrink)
+
+        // Then
+        assertNull(retrieved)
+    }
+
+    @Test
+    fun testGetAllFavorites() = runBlocking {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktails = listOf(
+            RoomCocktail("Mojito", "mojito.jpg", "11007"),
+            RoomCocktail("Margarita", "margarita.jpg", "11008"),
+            RoomCocktail("Martini", "martini.jpg", "11009")
+        )
+
+        // When
+        cocktails.forEach { cocktail ->
+            cocktailDao.insertCocktail(cocktail)
+            cocktailDao.insertFavorite(RoomFavorite(userEmail, cocktail.idDrink))
+        }
+        val favorites = cocktailDao.getFavoriteCocktails(userEmail)
+
+        // Then
+        assertNotNull(favorites)
+        assertEquals(3, favorites?.size)
+        assertEquals(cocktails[0].strDrink, favorites?.get(0)?.strDrink)
+        assertEquals(cocktails[1].strDrink, favorites?.get(1)?.strDrink)
+        assertEquals(cocktails[2].strDrink, favorites?.get(2)?.strDrink)
+    }
+
+    @Test
+    fun testUserIsolation() = runBlocking {
+        // Given
+        val user1 = "user1@example.com"
+        val user2 = "user2@example.com"
+        val cocktail1 = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        val cocktail2 = RoomCocktail("Margarita", "margarita.jpg", "11008")
+
+        // When
+        cocktailDao.insertCocktail( cocktail1)
+        cocktailDao.insertFavorite(RoomFavorite(user1, cocktail1.idDrink))
+        cocktailDao.insertCocktail( cocktail2)
+        cocktailDao.insertFavorite(RoomFavorite(user2, cocktail2.idDrink))
+
+        val user1Favorites = cocktailDao.getFavoriteCocktails(user1)
+        val user2Favorites = cocktailDao.getFavoriteCocktails(user2)
+
+        // Then
+        assertEquals(1, user1Favorites?.size)
+        assertEquals(1, user2Favorites?.size)
+        assertEquals(cocktail1.strDrink, user1Favorites?.get(0)?.strDrink)
+        assertEquals(cocktail2.strDrink, user2Favorites?.get(0)?.strDrink)
+    }
+}
diff --git a/app/src/androidTest/java/com/example/cocktailsdbapp/ui/AppFlowTest.kt b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/AppFlowTest.kt
new file mode 100644
index 0000000..03ba46c
--- /dev/null
+++ b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/AppFlowTest.kt
@@ -0,0 +1,221 @@
+package com.example.cocktailsdbapp.ui
+
+import android.view.View
+import androidx.recyclerview.widget.RecyclerView
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.UiController
+import androidx.test.espresso.ViewAction
+import androidx.test.espresso.action.ViewActions.*
+import androidx.test.espresso.assertion.ViewAssertions.*
+import androidx.test.espresso.contrib.RecyclerViewActions
+import androidx.test.espresso.matcher.ViewMatchers.*
+import androidx.test.ext.junit.rules.ActivityScenarioRule
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.LargeTest
+import com.example.cocktailsdbapp.MainActivity
+import com.example.cocktailsdbapp.R
+import com.example.cocktailsdbapp.ui.cocktails.CocktailsFragmentTest
+import org.hamcrest.Matcher
+import org.hamcrest.Matchers.not
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * Comprehensive Espresso Tests for App Flow
+ * Register -> Display Cocktails -> Select Category ->
+ * Select Filter -> Favorite Item -> Display Favorites ->
+ * Unfavorite Item -> Navigate to Profile -> Display Empty Favorites
+ */
+@RunWith(AndroidJUnit4::class)
+@LargeTest
+class AppFlowTest {
+
+    @get:Rule
+    val activityRule = ActivityScenarioRule(MainActivity::class.java)
+
+    private val testEmail = "cocktailstest@example.com"
+    private val testName = "Cocktails Test User"
+    private val testPassword = "password123"
+
+    @Before
+    fun setUp() {
+        // Register and login for each test
+        registerAndLoginUser()
+    }
+
+    private fun registerAndLoginUser() {
+        // Step 1: Navigate to Registration
+        try {
+            onView(withId(R.id.bt_register))
+                .perform(click())
+            Thread.sleep(1000)
+        } catch (e: Exception) {
+            // Might already be on registration screen
+        }
+
+        // Step 2: Register a new user
+        onView(withId(R.id.et_name_input))
+            .perform(clearText(), typeText(testName))
+
+        onView(withId(R.id.et_email_input))
+            .perform(clearText(), typeText(testEmail))
+
+        onView(withId(R.id.et_password_input))
+            .perform(clearText(), typeText(testPassword))
+
+        // Click register button
+        onView(withId(R.id.bt_register))
+            .perform(click())
+
+        // Wait for registration to complete
+        Thread.sleep(1000)
+
+        // Step 3: Handle the success dialog that appears after registration
+        try {
+            // Check if success dialog is displayed
+            onView(withText("Registration Successful!"))
+                .check(matches(isDisplayed()))
+
+            // Click OK button to dismiss the dialog
+            onView(withText("OK"))
+                .perform(click())
+
+            // Wait for navigation to cocktails fragment
+            Thread.sleep(1000)
+
+        } catch (e: Exception) {
+            // If no success dialog appears, registration might have failed
+            // Try to login manually
+            onView(withId(R.id.bt_login))
+                .perform(click())
+            Thread.sleep(1000)
+
+            // Fill login form
+            onView(withId(R.id.et_email_input))
+                .perform(clearText(), typeText(testEmail))
+
+            onView(withId(R.id.et_password_input))
+                .perform(clearText(), typeText(testPassword))
+
+            // Click login button
+            onView(withId(R.id.bt_login))
+                .perform(click())
+
+            // Wait for login to complete
+            Thread.sleep(1000)
+        }
+    }
+
+    object MyViewAction {
+        fun clickChildViewWithId(id: Int) = object : ViewAction {
+            override fun getConstraints(): Matcher<View> = isAssignableFrom(View::class.java)
+            override fun getDescription(): String = "Click on a child view with specified id."
+            override fun perform(uiController: UiController, view: View) {
+                val v = view.findViewById<View>(id)
+                v.performClick()
+            }
+        }
+    }
+
+    @Test
+    fun testAppFlow() {
+        try {
+            // Click on category
+            onView(withId(R.id.action_filter))
+                .perform(click())
+
+            // Wait to show category list
+            Thread.sleep(1000)
+
+            // Verify categories are listed
+            onView(withId(R.id.rv_filter))
+                .check(matches(isDisplayed()))
+
+            // Click on second category
+            onView(withId(R.id.rv_filter))
+                .perform(
+                    RecyclerViewActions.actionOnItemAtPosition<RecyclerView.ViewHolder>(
+                        1, // position
+                        MyViewAction.clickChildViewWithId(R.id.cl_filter_view)
+                    )
+                )
+
+            // Wait to show filter list
+            Thread.sleep(1000)
+
+            // Verify filters are listed
+            onView(withId(R.id.rv_filter))
+                .check(matches(isDisplayed()))
+
+            // Click on first filter
+            onView(withId(R.id.rv_filter))
+                .perform(
+                    RecyclerViewActions.actionOnItemAtPosition<RecyclerView.ViewHolder>(
+                        0, // position
+                        MyViewAction.clickChildViewWithId(R.id.cl_filter_view)
+                    )
+                )
+
+            // Wait to navigate to cocktails screen
+            Thread.sleep(1000)
+
+            // Verify cocktails are loaded
+            onView(withId(R.id.rv_cocktails))
+                .check(matches(isDisplayed()))
+
+            // Favorite first item, so the favorites screen is not empty
+            onView(withId(R.id.rv_cocktails))
+                .perform(
+                    RecyclerViewActions.actionOnItemAtPosition<RecyclerView.ViewHolder>(
+                        0, // position
+                        MyViewAction.clickChildViewWithId(R.id.iv_favorite)
+                    )
+                )
+
+            Thread.sleep(1000)
+
+            // Click on favorites tab
+            onView(withId(R.id.navigation_favorites))
+                .perform(click())
+
+            Thread.sleep(1000)
+
+            onView(withId(R.id.rv_cocktails))
+                .check(matches(isDisplayed()))
+
+            // Unfavorite the item, so the favorites screen is empty
+            onView(withId(R.id.rv_cocktails))
+                .perform(
+                    RecyclerViewActions.actionOnItemAtPosition<RecyclerView.ViewHolder>(
+                        0, // position
+                        MyViewAction.clickChildViewWithId(R.id.iv_favorite)
+                    )
+                )
+
+            Thread.sleep(1000)
+
+            // Click on profile tab
+            onView(withId(R.id.navigation_profile))
+                .perform(click())
+
+            // Verify profile component is displayed
+            onView(withId(R.id.til_name_input))
+                .check(matches(isDisplayed()))
+
+            // Click on fav tab
+            onView(withId(R.id.navigation_favorites))
+                .perform(click())
+
+            Thread.sleep(1000)
+
+            onView(withId(R.id.rv_cocktails))
+                .check(matches(not(isDisplayed())))
+
+        } catch (e: Exception) {
+            assert(false)
+        }
+    }
+
+}
diff --git a/app/src/androidTest/java/com/example/cocktailsdbapp/ui/MainActivityTest.kt b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/MainActivityTest.kt
new file mode 100644
index 0000000..88c5500
--- /dev/null
+++ b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/MainActivityTest.kt
@@ -0,0 +1,54 @@
+package com.example.cocktailsdbapp.ui
+
+import androidx.test.ext.junit.rules.ActivityScenarioRule
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.LargeTest
+import com.example.cocktailsdbapp.MainActivity
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * Espresso Tests for MainActivity
+ * Tests basic activity functionality
+ */
+@RunWith(AndroidJUnit4::class)
+@LargeTest
+class MainActivityTest {
+
+    @get:Rule
+    val activityRule = ActivityScenarioRule(MainActivity::class.java)
+
+    @Test
+    fun testMainActivityLaunches() {
+        // Test that MainActivity launches successfully
+        activityRule.scenario.onActivity { activity ->
+            assert(activity != null)
+            assert(activity.isFinishing.not())
+        }
+    }
+
+    @Test
+    fun testActivityNotFinishing() {
+        // Test that activity is not finishing after launch
+        activityRule.scenario.onActivity { activity ->
+            assert(!activity.isFinishing)
+        }
+    }
+
+    @Test
+    fun testActivityHasWindowFocus() {
+        // Test that activity has window focus
+        activityRule.scenario.onActivity { activity ->
+            assert(activity.hasWindowFocus())
+        }
+    }
+
+    @Test
+    fun testActivityIsNotDestroyed() {
+        // Test that activity is not destroyed
+        activityRule.scenario.onActivity { activity ->
+            assert(!activity.isDestroyed)
+        }
+    }
+}
diff --git a/app/src/androidTest/java/com/example/cocktailsdbapp/ui/authorization/LoginFragmentTest.kt b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/authorization/LoginFragmentTest.kt
new file mode 100644
index 0000000..d830a28
--- /dev/null
+++ b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/authorization/LoginFragmentTest.kt
@@ -0,0 +1,140 @@
+package com.example.cocktailsdbapp.ui.authorization
+
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.action.ViewActions.*
+import androidx.test.espresso.assertion.ViewAssertions.*
+import androidx.test.espresso.matcher.ViewMatchers.*
+import androidx.test.ext.junit.rules.ActivityScenarioRule
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.LargeTest
+import com.example.cocktailsdbapp.MainActivity
+import com.example.cocktailsdbapp.R
+import org.hamcrest.Matchers.containsString
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * Espresso Tests for LoginFragment
+ * Tests login functionality and UI interactions
+ */
+@RunWith(AndroidJUnit4::class)
+@LargeTest
+class LoginFragmentTest {
+
+    @get:Rule
+    val activityRule = ActivityScenarioRule(MainActivity::class.java)
+
+    @Test
+    fun testLoginFragmentDisplaysCorrectly() {
+        // Check if login button is displayed
+        onView(withId(R.id.bt_login))
+            .check(matches(isDisplayed()))
+        
+        // Check if email field is displayed
+        onView(withId(R.id.et_email_input))
+            .check(matches(isDisplayed()))
+        
+        // Check if password field is displayed
+        onView(withId(R.id.et_password_input))
+            .check(matches(isDisplayed()))
+    }
+
+    @Test
+    fun testEmailFieldInteraction() {
+        
+        onView(withId(R.id.et_email_input))
+            .perform(typeText("test@example.com"))
+            .check(matches(withText("test@example.com")))
+    }
+
+    @Test
+    fun testPasswordFieldInteraction() {
+        
+        onView(withId(R.id.et_password_input))
+            .perform(click())
+            .perform(typeText("password123"))
+            .check(matches(withText("password123")))
+    }
+
+    @Test
+    fun testRegisterButtonClick() {
+        
+        onView(withId(R.id.bt_register))
+            .perform(click())
+
+        // Wait for navigation to finish
+        Thread.sleep(1000)
+
+        // Check if we are on registration screen
+        onView(withId(R.id.tv_register))
+            .check(matches(isDisplayed()))
+    }
+
+    @Test
+    fun testEmptyEmailValidation() {
+        // Test validation with empty email
+        
+        onView(withId(R.id.et_password_input))
+            .perform(typeText("password123"))
+        
+        onView(withId(R.id.bt_login))
+            .perform(click())
+        
+        // Should stay on login screen
+        onView(withId(R.id.et_email_input))
+            .check(matches(isDisplayed()))
+    }
+
+    @Test
+    fun testEmptyPasswordValidation() {
+        // Test validation with empty password
+        
+        onView(withId(R.id.et_email_input))
+            .perform(typeText("test@example.com"))
+        
+        onView(withId(R.id.bt_login))
+            .perform(click())
+        
+        // Should stay on login screen
+        onView(withId(R.id.et_password_input))
+            .check(matches(isDisplayed()))
+    }
+
+    @Test
+    fun testInvalidEmailFormat() {
+        onView(withId(R.id.et_password_input))
+            .perform(clearText(), typeText("password123"))
+
+        // Chars < 3
+        onView(withId(R.id.et_email_input))
+            .perform(clearText(), typeText("in"))
+
+        onView(withId(R.id.bt_login))
+            .perform(click())
+        
+        // Should show validation error
+        onView(withId(R.id.et_email_input))
+            .check(matches(hasErrorText(containsString("Input must be at least 3 characters"))))
+    }
+
+    @Test
+    fun testLoginWithInvalidCredentials() {
+        // Test login with non existent user
+        
+        onView(withId(R.id.et_email_input))
+            .perform(typeText("invalid@example.com"))
+        
+        onView(withId(R.id.et_password_input))
+            .perform(typeText("password"))
+        
+        onView(withId(R.id.bt_login))
+            .perform(click())
+        
+        // Should stay on login screen
+        Thread.sleep(1000)
+        
+        onView(withId(R.id.et_email_input))
+            .check(matches(isDisplayed()))
+    }
+}
diff --git a/app/src/androidTest/java/com/example/cocktailsdbapp/ui/authorization/RegistrationFragmentTest.kt b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/authorization/RegistrationFragmentTest.kt
new file mode 100644
index 0000000..ecf0bc3
--- /dev/null
+++ b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/authorization/RegistrationFragmentTest.kt
@@ -0,0 +1,353 @@
+package com.example.cocktailsdbapp.ui.authorization
+
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.action.ViewActions.*
+import androidx.test.espresso.assertion.ViewAssertions.*
+import androidx.test.espresso.matcher.ViewMatchers.*
+import androidx.test.ext.junit.rules.ActivityScenarioRule
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.LargeTest
+import com.example.cocktailsdbapp.MainActivity
+import com.example.cocktailsdbapp.R
+import org.hamcrest.Matchers.*
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * Espresso Tests for RegistrationFragment
+ * Tests user registration functionality and UI interactions
+ */
+@RunWith(AndroidJUnit4::class)
+@LargeTest
+class RegistrationFragmentTest {
+
+    @get:Rule
+    val activityRule = ActivityScenarioRule(MainActivity::class.java)
+
+    private fun navigateToRegistrationFragment() {
+        // Navigate to registration fragment via login screen
+        // First navigate to login, then to registration
+        onView(withId(R.id.bt_register))
+            .perform(click())
+        Thread.sleep(1000)
+    }
+
+    @Test
+    fun testRegistrationFragmentDisplaysCorrectly() {
+        // Test that registration fragment displays correctly
+        navigateToRegistrationFragment()
+        
+        // Check if all UI elements are displayed
+        onView(withId(R.id.tv_register))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.et_name_input))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.et_email_input))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.et_password_input))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.bt_register))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.bt_login))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.ll_spacer))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.tv_or))
+            .check(matches(isDisplayed()))
+    }
+
+    @Test
+    fun testNameInputInteraction() {
+        navigateToRegistrationFragment()
+        
+        // Test name field interaction
+        onView(withId(R.id.et_name_input))
+            .perform(click())
+            .perform(typeText("John Doe"))
+        
+        // Verify text was entered
+        onView(withId(R.id.et_name_input))
+            .check(matches(withText("John Doe")))
+    }
+
+    @Test
+    fun testEmailInputInteraction() {
+        navigateToRegistrationFragment()
+        
+        // Test email field interaction
+        onView(withId(R.id.et_email_input))
+            .perform(click())
+            .perform(typeText("john.doe@example.com"))
+        
+        // Verify text was entered
+        onView(withId(R.id.et_email_input))
+            .check(matches(withText("john.doe@example.com")))
+    }
+
+    @Test
+    fun testPasswordInputInteraction() {
+        navigateToRegistrationFragment()
+        
+        // Test password field interaction
+        onView(withId(R.id.et_password_input))
+            .perform(click())
+            .perform(typeText("password123"))
+        
+        // Verify text was entered
+        onView(withId(R.id.et_password_input))
+            .check(matches(withText("password123")))
+    }
+
+    @Test
+    fun testEmailValidation() {
+        // Test email validation with short input
+        navigateToRegistrationFragment()
+        
+        // Enter short email (less than minimum characters)
+        onView(withId(R.id.et_email_input))
+            .perform(click())
+            .perform(typeText("ab"))
+        
+        // Check that error is displayed
+        onView(withId(R.id.et_email_input))
+            .check(matches(hasErrorText(containsString("Input must be at least 3 characters"))))
+    }
+
+    @Test
+    fun testPasswordValidation() {
+        // Test password validation with short input
+        navigateToRegistrationFragment()
+        
+        // Enter short password (less than minimum characters)
+        onView(withId(R.id.et_password_input))
+            .perform(click())
+            .perform(typeText("12"))
+        
+        // Check that error is displayed
+        onView(withId(R.id.et_password_input))
+            .check(matches(hasErrorText(containsString("Input must be at least 3 characters"))))
+    }
+
+    @Test
+    fun testValidInputRemovesError() {
+        // Test that valid input removes error messages
+        navigateToRegistrationFragment()
+        
+        // First enter invalid input
+        onView(withId(R.id.et_email_input))
+            .perform(click())
+            .perform(typeText("ab"))
+        
+        // Verify error is shown
+        onView(withId(R.id.et_email_input))
+            .check(matches(hasErrorText(containsString("Input must be at least 3 characters"))))
+        
+        // Now enter valid input
+        onView(withId(R.id.et_email_input))
+            .perform(clearText())
+            .perform(typeText("valid@email.com"))
+        
+        // Verify error is removed
+        onView(withId(R.id.et_email_input))
+            .check(matches(not(hasErrorText(containsString("Input must be at least 3 characters")))))
+    }
+
+    @Test
+    fun testRegisterButtonWithValidInput() {
+        // Test register button with valid input
+        navigateToRegistrationFragment()
+        
+        // Fill in all fields with valid data
+        onView(withId(R.id.et_name_input))
+            .perform(typeText("John Doe"))
+        
+        onView(withId(R.id.et_email_input))
+            .perform(typeText("john.doe@example.com"))
+        
+        onView(withId(R.id.et_password_input))
+            .perform(typeText("password123"))
+        
+        // Click register button
+        onView(withId(R.id.bt_register))
+            .perform(click())
+        
+        // Wait for registration process
+        Thread.sleep(2000)
+    }
+
+    @Test
+    fun testRegisterButtonWithInvalidInput() {
+        // Test register button with invalid input
+        navigateToRegistrationFragment()
+        
+        // Fill in fields with invalid data (too short)
+        onView(withId(R.id.et_name_input))
+            .perform(typeText("John"))
+        
+        onView(withId(R.id.et_email_input))
+            .perform(typeText("ab"))
+        
+        onView(withId(R.id.et_password_input))
+            .perform(typeText("12"))
+        
+        // Click register button
+        onView(withId(R.id.bt_register))
+            .perform(click())
+        
+        // Should stay on registration screen
+        onView(withId(R.id.bt_register))
+            .check(matches(isDisplayed()))
+    }
+
+    @Test
+    fun testLoginButtonNavigation() {
+        // Test navigation to login screen
+        navigateToRegistrationFragment()
+        
+        // Click login button
+        onView(withId(R.id.bt_login))
+            .perform(click())
+        
+        // Wait for navigation
+        Thread.sleep(1000)
+        
+        // Should be on login screen (verify by checking login-specific elements)
+        onView(withId(R.id.bt_login))
+            .check(matches(isDisplayed()))
+    }
+
+    @Test
+    fun testInputFieldFocus() {
+        // Test input field focus behavior
+        navigateToRegistrationFragment()
+        
+        // Test name field focus
+        onView(withId(R.id.et_name_input))
+            .perform(click())
+            .check(matches(hasFocus()))
+        
+        // Test email field focus
+        onView(withId(R.id.et_email_input))
+            .perform(click())
+            .check(matches(hasFocus()))
+        
+        // Test password field focus
+        onView(withId(R.id.et_password_input))
+            .perform(click())
+            .check(matches(hasFocus()))
+    }
+
+    @Test
+    fun testInputFieldClearing() {
+        // Test clearing input fields
+        navigateToRegistrationFragment()
+        
+        // Enter text in all fields
+        onView(withId(R.id.et_name_input))
+            .perform(typeText("John Doe"))
+        
+        onView(withId(R.id.et_email_input))
+            .perform(typeText("john@example.com"))
+        
+        onView(withId(R.id.et_password_input))
+            .perform(typeText("password123"))
+        
+        // Clear all fields
+        onView(withId(R.id.et_name_input))
+            .perform(clearText())
+        
+        onView(withId(R.id.et_email_input))
+            .perform(clearText())
+        
+        onView(withId(R.id.et_password_input))
+            .perform(clearText())
+        
+        // Verify fields are empty
+        onView(withId(R.id.et_name_input))
+            .check(matches(withText("")))
+        
+        onView(withId(R.id.et_email_input))
+            .check(matches(withText("")))
+        
+        onView(withId(R.id.et_password_input))
+            .check(matches(withText("")))
+    }
+
+    @Test
+    fun testRegistrationWithLongInputs() {
+        // Test registration with long inputs
+        navigateToRegistrationFragment()
+        
+        val longName = "A".repeat(30)
+        val longEmail = "a".repeat(20) + "@example.com"
+        val longPassword = "p".repeat(30)
+        
+        // Test long name
+        onView(withId(R.id.et_name_input))
+            .perform(typeText(longName))
+        
+        // Test long email
+        onView(withId(R.id.et_email_input))
+            .perform(typeText(longEmail))
+        
+        // Test long password
+        onView(withId(R.id.et_password_input))
+            .perform(typeText(longPassword))
+        
+        // Verify all fields accept long inputs
+        onView(withId(R.id.et_name_input))
+            .check(matches(withText(longName)))
+        
+        onView(withId(R.id.et_email_input))
+            .check(matches(withText(longEmail)))
+        
+        onView(withId(R.id.et_password_input))
+            .check(matches(withText(longPassword)))
+    }
+
+    @Test
+    fun testRegistrationFormValidation() {
+        // Test complete form validation
+        navigateToRegistrationFragment()
+        
+        // Test with empty fields
+        onView(withId(R.id.bt_register))
+            .perform(click())
+        
+        // Should stay on registration screen
+        onView(withId(R.id.bt_register))
+            .check(matches(isDisplayed()))
+        
+        // Test with partial data
+        onView(withId(R.id.et_name_input))
+            .perform(typeText("John"))
+        
+        onView(withId(R.id.bt_register))
+            .perform(click())
+        
+        // Should still stay on registration screen
+        onView(withId(R.id.bt_register))
+            .check(matches(isDisplayed()))
+        
+        // Test with valid data
+        onView(withId(R.id.et_email_input))
+            .perform(typeText("john@example.com"))
+        
+        onView(withId(R.id.et_password_input))
+            .perform(typeText("password123"))
+        
+        onView(withId(R.id.bt_register))
+            .perform(click())
+        
+        // Wait for registration process
+        Thread.sleep(2000)
+    }
+}
diff --git a/app/src/androidTest/java/com/example/cocktailsdbapp/ui/cocktails/CocktailsFragmentTest.kt b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/cocktails/CocktailsFragmentTest.kt
new file mode 100644
index 0000000..abbc9b8
--- /dev/null
+++ b/app/src/androidTest/java/com/example/cocktailsdbapp/ui/cocktails/CocktailsFragmentTest.kt
@@ -0,0 +1,252 @@
+package com.example.cocktailsdbapp.ui.cocktails
+
+import android.view.View
+import androidx.recyclerview.widget.RecyclerView
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.UiController
+import androidx.test.espresso.ViewAction
+import androidx.test.espresso.action.ViewActions.*
+import androidx.test.espresso.assertion.ViewAssertions.*
+import androidx.test.espresso.contrib.RecyclerViewActions
+import androidx.test.espresso.matcher.ViewMatchers.*
+import androidx.test.ext.junit.rules.ActivityScenarioRule
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.LargeTest
+import com.example.cocktailsdbapp.MainActivity
+import com.example.cocktailsdbapp.R
+import org.hamcrest.Matcher
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * Comprehensive Espresso Tests for CocktailsFragment
+ * Tests: Registration -> Login -> Cocktails Fragment functionality
+ */
+@RunWith(AndroidJUnit4::class)
+@LargeTest
+class CocktailsFragmentTest {
+
+    @get:Rule
+    val activityRule = ActivityScenarioRule(MainActivity::class.java)
+
+    private val testEmail = "cocktailstest@example.com"
+    private val testName = "Cocktails Test User"
+    private val testPassword = "password123"
+
+    @Before
+    fun setUp() {
+        // Register and login for each test
+        registerAndLoginUser()
+    }
+
+    private fun registerAndLoginUser() {
+        // Step 1: Navigate to Registration
+        try {
+            onView(withId(R.id.bt_register))
+                .perform(click())
+            Thread.sleep(1000)
+        } catch (e: Exception) {
+            // Might already be on registration screen
+        }
+
+        // Step 2: Register a new user
+        onView(withId(R.id.et_name_input))
+            .perform(clearText(), typeText(testName))
+
+        onView(withId(R.id.et_email_input))
+            .perform(clearText(), typeText(testEmail))
+
+        onView(withId(R.id.et_password_input))
+            .perform(clearText(), typeText(testPassword))
+
+        // Click register button
+        onView(withId(R.id.bt_register))
+            .perform(click())
+
+        // Wait for registration to complete
+        Thread.sleep(1000)
+
+        // Step 3: Handle the success dialog that appears after registration
+        try {
+            // Check if success dialog is displayed
+            onView(withText("Registration Successful!"))
+                .check(matches(isDisplayed()))
+
+            // Click OK button to dismiss the dialog
+            onView(withText("OK"))
+                .perform(click())
+
+            // Wait for navigation to cocktails fragment
+            Thread.sleep(1000)
+
+        } catch (e: Exception) {
+            // If no success dialog appears, registration might have failed
+            // Try to login manually
+            onView(withId(R.id.bt_login))
+                .perform(click())
+            Thread.sleep(1000)
+
+            // Fill login form
+            onView(withId(R.id.et_email_input))
+                .perform(clearText(), typeText(testEmail))
+
+            onView(withId(R.id.et_password_input))
+                .perform(clearText(), typeText(testPassword))
+
+            // Click login button
+            onView(withId(R.id.bt_login))
+                .perform(click())
+
+            // Wait for login to complete
+            Thread.sleep(1000)
+        }
+    }
+
+    object MyViewAction {
+        fun clickChildViewWithId(id: Int) = object : ViewAction {
+            override fun getConstraints(): Matcher<View> = isAssignableFrom(View::class.java)
+            override fun getDescription(): String = "Click on a child view with specified id."
+            override fun perform(uiController: UiController, view: View) {
+                val v = view.findViewById<View>(id)
+                v.performClick()
+            }
+        }
+    }
+
+    @Test
+    fun testCocktailsFragmentDisplaysCorrectly() {
+        // Verify we're on the cocktails fragment
+        onView(withId(R.id.rv_cocktails))
+            .check(matches(isDisplayed()))
+        
+        // Verify filter label is displayed
+        onView(withId(R.id.ll_label))
+            .check(matches(isDisplayed()))
+        
+        // Verify toolbar elements
+        onView(withId(R.id.action_search))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.action_filter))
+            .check(matches(isDisplayed()))
+        
+        // Verify bottom navigation
+        onView(withId(R.id.bottomNavigationMenu))
+            .check(matches(isDisplayed()))
+        
+        // Verify navigation tabs
+        onView(withId(R.id.navigation_cocktails))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.navigation_favorites))
+            .check(matches(isDisplayed()))
+        
+        onView(withId(R.id.navigation_profile))
+            .check(matches(isDisplayed()))
+    }
+
+    @Test
+    fun testCocktailsRecyclerViewHasItems() {
+        // Wait for data to load
+        Thread.sleep(1000)
+
+        // Verify RecyclerView is displayed and has items
+        onView(withId(R.id.rv_cocktails))
+            .check(matches(isDisplayed()))
+            .check(matches(hasMinimumChildCount(1)))
+    }
+
+    @Test
+    fun testCocktailsRecyclerViewIsScrollable() {
+        // Wait for data to load
+        Thread.sleep(1000)
+
+        // Verify RecyclerView is scrollable
+        onView(withId(R.id.rv_cocktails))
+            .check(matches(isDisplayed()))
+            .perform(swipeUp())
+            .perform(swipeDown())
+    }
+
+    @Test
+    fun testCocktailsItemClick() {
+        // Wait for data to load
+        Thread.sleep(1000)
+
+        // Click on first cocktail item
+        try {
+            onView(withId(R.id.rv_cocktails))
+                .perform(
+                    RecyclerViewActions.actionOnItemAtPosition<RecyclerView.ViewHolder>(
+                        0, // position
+                        MyViewAction.clickChildViewWithId(R.id.iv_drink)
+                    )
+                )
+        } catch (e: Exception) {
+            assert(false)
+        }
+    }
+
+    @Test
+    fun testCocktailsFavoriteButtonClick() {
+        // Wait for data to load
+        Thread.sleep(1000)
+
+        // Try to click on favorite button of first item
+        try {
+            onView(withId(R.id.rv_cocktails))
+                .perform(
+                    RecyclerViewActions.actionOnItemAtPosition<RecyclerView.ViewHolder>(
+                        0, // position
+                        MyViewAction.clickChildViewWithId(R.id.iv_favorite)
+                    )
+                )
+
+            // Wait for favorite action to complete
+            Thread.sleep(1000)
+
+        } catch (e: Exception) {
+            assert(false)
+        }
+    }
+
+    @Test
+    fun testCocktailsSearchAction() {
+        // Click on search action in toolbar
+        onView(withId(R.id.action_search))
+            .perform(click())
+        
+        // Wait for search to open
+        Thread.sleep(1000)
+        
+        // Try to interact with search (if it opens)
+        try {
+            // This should expand search input field
+            onView(withId(R.id.action_search_input))
+                .check(matches(isDisplayed()))
+        } catch (e: Exception) {
+            assert(false)
+        }
+    }
+
+    @Test
+    fun testCocktailsFilterAction() {
+        // Click on filter action in toolbar
+        onView(withId(R.id.action_filter))
+            .perform(click())
+        
+        // Wait for filter to open
+        Thread.sleep(1000)
+        
+        // Try to interact with filter (if it opens)
+        try {
+            // This should open a filter list
+            onView(withId(R.id.rv_filter))
+                .check(matches(isDisplayed()))
+        } catch (e: Exception) {
+            assert(false)
+        }
+    }
+}
diff --git a/app/src/test/java/com/example/cocktailsdbapp/database/RoomCocktailTest.kt b/app/src/test/java/com/example/cocktailsdbapp/database/RoomCocktailTest.kt
new file mode 100644
index 0000000..e71f97b
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/database/RoomCocktailTest.kt
@@ -0,0 +1,105 @@
+package com.example.cocktailsdbapp.database
+
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for RoomCocktail data class
+ */
+class RoomCocktailTest {
+
+    @Test
+    fun `test RoomCocktail data class basic functionality`() {
+        // Given
+        val roomCocktail = RoomCocktail(
+            strDrink = "Mojito",
+            strDrinkThumb = "mojito.jpg",
+            idDrink = "11007"
+        )
+        
+        // Then
+        assertEquals("Mojito", roomCocktail.strDrink)
+        assertEquals("mojito.jpg", roomCocktail.strDrinkThumb)
+        assertEquals("11007", roomCocktail.idDrink)
+    }
+
+    @Test
+    fun `test RoomCocktail data class equality`() {
+        // Given
+        val roomCocktail1 = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        val roomCocktail2 = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        val roomCocktail3 = RoomCocktail("Margarita", "margarita.jpg", "11008")
+        
+        // Then
+        assertEquals(roomCocktail1, roomCocktail2)
+        assertNotEquals(roomCocktail1, roomCocktail3)
+    }
+
+    @Test
+    fun `test RoomCocktail toString method`() {
+        // Given
+        val roomCocktail = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        
+        // When
+        val result = roomCocktail.toString()
+        
+        // Then
+        assertTrue(result.contains("Mojito"))
+        assertTrue(result.contains("mojito.jpg"))
+        assertTrue(result.contains("11007"))
+    }
+
+    @Test
+    fun `test RoomCocktail with empty strings`() {
+        // Given
+        val roomCocktail = RoomCocktail("", "", "")
+        
+        // Then
+        assertEquals("", roomCocktail.strDrink)
+        assertEquals("", roomCocktail.strDrinkThumb)
+        assertEquals("", roomCocktail.idDrink)
+    }
+
+    @Test
+    fun `test RoomCocktail copy functionality`() {
+        // Given
+        val original = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        
+        // When
+        val copied = original.copy(strDrink = "Cuba Libre")
+        
+        // Then
+        assertEquals("Cuba Libre", copied.strDrink)
+        assertEquals("mojito.jpg", copied.strDrinkThumb)
+        assertEquals("11007", copied.idDrink)
+        assertEquals("Mojito", original.strDrink)
+    }
+
+    @Test
+    fun `test RoomCocktail list operations`() {
+        // Given
+        val cocktails = listOf(
+            RoomCocktail("Mojito", "mojito.jpg", "11007"),
+            RoomCocktail("Margarita", "margarita.jpg", "11008"),
+            RoomCocktail("Martini", "martini.jpg", "11009")
+        )
+        
+        // When
+        val filtered = cocktails.filter { it.strDrink.startsWith("M") }
+        
+        // Then
+        assertEquals(3, filtered.size)
+        assertTrue(filtered.all { it.strDrink.startsWith("M") })
+    }
+
+    @Test
+    fun `test RoomCocktail hashCode consistency`() {
+        // Given
+        val roomCocktail1 = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        val roomCocktail2 = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        
+        // Then
+        assertEquals(roomCocktail1.hashCode(), roomCocktail2.hashCode())
+    }
+}
+
diff --git a/app/src/test/java/com/example/cocktailsdbapp/model/CocktailResponseTest.kt b/app/src/test/java/com/example/cocktailsdbapp/model/CocktailResponseTest.kt
new file mode 100644
index 0000000..38a067c
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/model/CocktailResponseTest.kt
@@ -0,0 +1,117 @@
+package com.example.cocktailsdbapp.model
+
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for CocktailResponse data class
+ */
+class CocktailResponseTest {
+
+    @Test
+    fun `test CocktailResponse data class with drinks`() {
+        // Given
+        val cocktails = listOf(
+            Cocktail("Mojito", "mojito.jpg", "11007", true),
+            Cocktail("Margarita", "margarita.jpg", "11008", false)
+        )
+        val response = CocktailResponse(cocktails)
+        
+        // Then
+        assertNotNull(response.drinks)
+        assertEquals(2, response.drinks?.size)
+        assertEquals("Mojito", response.drinks?.get(0)?.strDrink)
+        assertEquals("Margarita", response.drinks?.get(1)?.strDrink)
+    }
+
+    @Test
+    fun `test CocktailResponse data class with null drinks`() {
+        // Given
+        val response = CocktailResponse(null)
+        
+        // Then
+        assertNull(response.drinks)
+    }
+
+    @Test
+    fun `test CocktailResponse with empty list`() {
+        // Given
+        val response = CocktailResponse(emptyList())
+        
+        // Then
+        assertNotNull(response.drinks)
+        assertEquals(0, response.drinks?.size)
+        assertTrue(response.drinks!!.isEmpty())
+    }
+
+    @Test
+    fun `test CocktailResponse equality`() {
+        // Given
+        val cocktails1 = listOf(Cocktail("Mojito", "mojito.jpg", "11007", true))
+        val cocktails2 = listOf(Cocktail("Mojito", "mojito.jpg", "11007", true))
+        val response1 = CocktailResponse(cocktails1)
+        val response2 = CocktailResponse(cocktails2)
+        
+        // Then
+        assertEquals(response1, response2)
+    }
+
+    @Test
+    fun `test CocktailResponse with single cocktail`() {
+        // Given
+        val singleCocktail = listOf(Cocktail("Mojito", "mojito.jpg", "11007", false))
+        val response = CocktailResponse(singleCocktail)
+        
+        // Then
+        assertNotNull(response.drinks)
+        assertEquals(1, response.drinks?.size)
+        assertEquals("Mojito", response.drinks?.first()?.strDrink)
+    }
+
+    @Test
+    fun `test CocktailResponse copy functionality`() {
+        // Given
+        val originalCocktails = listOf(Cocktail("Mojito", "mojito.jpg", "11007", true))
+        val original = CocktailResponse(originalCocktails)
+        
+        // When
+        val newCocktails = listOf(Cocktail("Margarita", "margarita.jpg", "11008", false))
+        val copied = original.copy(drinks = newCocktails)
+        
+        // Then
+        assertEquals("Margarita", copied.drinks?.first()?.strDrink)
+        assertEquals("Mojito", original.drinks?.first()?.strDrink)
+    }
+
+    @Test
+    fun `test CocktailResponse toString method`() {
+        // Given
+        val cocktails = listOf(Cocktail("Mojito", "mojito.jpg", "11007", true))
+        val response = CocktailResponse(cocktails)
+        
+        // When
+        val result = response.toString()
+        
+        // Then
+        assertTrue(result.contains("CocktailResponse"))
+    }
+
+    @Test
+    fun `test CocktailResponse with multiple cocktails filtering`() {
+        // Given
+        val cocktails = listOf(
+            Cocktail("Mojito", "mojito.jpg", "11007", true),
+            Cocktail("Margarita", "margarita.jpg", "11008", false),
+            Cocktail("Martini", "martini.jpg", "11009", true)
+        )
+        val response = CocktailResponse(cocktails)
+        
+        // When
+        val favorites = response.drinks?.filter { it.isFavorite }
+        
+        // Then
+        assertNotNull(favorites)
+        assertEquals(2, favorites?.size)
+    }
+}
+
diff --git a/app/src/test/java/com/example/cocktailsdbapp/model/CocktailTest.kt b/app/src/test/java/com/example/cocktailsdbapp/model/CocktailTest.kt
new file mode 100644
index 0000000..4bf513f
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/model/CocktailTest.kt
@@ -0,0 +1,118 @@
+package com.example.cocktailsdbapp.model
+
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for Cocktail data class
+ */
+class CocktailTest {
+
+    @Test
+    fun `test Cocktail data class basic functionality`() {
+        // Given
+        val cocktail = Cocktail(
+            strDrink = "Mojito",
+            strDrinkThumb = "mojito.jpg",
+            idDrink = "11007",
+            isFavorite = true
+        )
+        
+        // Then
+        assertEquals("Mojito", cocktail.strDrink)
+        assertEquals("mojito.jpg", cocktail.strDrinkThumb)
+        assertEquals("11007", cocktail.idDrink)
+        assertTrue(cocktail.isFavorite)
+    }
+
+    @Test
+    fun `test Cocktail data class with default isFavorite`() {
+        // Given
+        val cocktail = Cocktail(
+            strDrink = "Margarita",
+            strDrinkThumb = "margarita.jpg",
+            idDrink = "11008"
+        )
+        
+        // Then
+        assertEquals("Margarita", cocktail.strDrink)
+        assertEquals("margarita.jpg", cocktail.strDrinkThumb)
+        assertEquals("11008", cocktail.idDrink)
+        assertFalse(cocktail.isFavorite)
+    }
+
+    @Test
+    fun `test Cocktail data class equality`() {
+        // Given
+        val cocktail1 = Cocktail("Mojito", "mojito.jpg", "11007", true)
+        val cocktail2 = Cocktail("Mojito", "mojito.jpg", "11007", true)
+        val cocktail3 = Cocktail("Margarita", "margarita.jpg", "11008", false)
+        
+        // Then
+        assertEquals(cocktail1, cocktail2)
+        assertNotEquals(cocktail1, cocktail3)
+    }
+
+    @Test
+    fun `test Cocktail data class copy`() {
+        // Given
+        val original = Cocktail("Mojito", "mojito.jpg", "11007", false)
+        
+        // When
+        val copied = original.copy(isFavorite = true)
+        
+        // Then
+        assertEquals("Mojito", copied.strDrink)
+        assertEquals("mojito.jpg", copied.strDrinkThumb)
+        assertEquals("11007", copied.idDrink)
+        assertTrue(copied.isFavorite)
+        assertFalse(original.isFavorite)
+    }
+
+    @Test
+    fun `test Cocktail toString method`() {
+        // Given
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", true)
+        
+        // When
+        val result = cocktail.toString()
+        
+        // Then
+        assertTrue(result.contains("Mojito"))
+        assertTrue(result.contains("mojito.jpg"))
+        assertTrue(result.contains("11007"))
+        assertTrue(result.contains("true"))
+    }
+
+    @Test
+    fun `test Cocktail with empty strings`() {
+        // Given
+        val cocktail = Cocktail("", "", "", false)
+        
+        // Then
+        assertEquals("", cocktail.strDrink)
+        assertEquals("", cocktail.strDrinkThumb)
+        assertEquals("", cocktail.idDrink)
+        assertFalse(cocktail.isFavorite)
+    }
+
+    @Test
+    fun `test Cocktail list operations`() {
+        // Given
+        val cocktails = listOf(
+            Cocktail("Mojito", "mojito.jpg", "11007", true),
+            Cocktail("Margarita", "margarita.jpg", "11008", false),
+            Cocktail("Martini", "martini.jpg", "11009", false)
+        )
+        
+        // When
+        val favorites = cocktails.filter { it.isFavorite }
+        val nonFavorites = cocktails.filter { !it.isFavorite }
+        
+        // Then
+        assertEquals(1, favorites.size)
+        assertEquals(2, nonFavorites.size)
+        assertEquals("Mojito", favorites[0].strDrink)
+    }
+}
+
diff --git a/app/src/test/java/com/example/cocktailsdbapp/model/UserTest.kt b/app/src/test/java/com/example/cocktailsdbapp/model/UserTest.kt
new file mode 100644
index 0000000..4a43f04
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/model/UserTest.kt
@@ -0,0 +1,371 @@
+package com.example.cocktailsdbapp.model
+
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for User data class
+ */
+class UserTest {
+
+    @Test
+    fun `user creation with valid data`() {
+        // Given
+        val name = "John Doe"
+        val email = "john.doe@example.com"
+        val password = "password123"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals(name, user.name)
+        assertEquals(email, user.email)
+        assertEquals(password, user.password)
+    }
+
+    @Test
+    fun `user creation with empty strings`() {
+        // Given
+        val name = ""
+        val email = ""
+        val password = ""
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("", user.name)
+        assertEquals("", user.email)
+        assertEquals("", user.password)
+    }
+
+    @Test
+    fun `user creation with special characters`() {
+        // Given
+        val name = "Jos Mara"
+        val email = "jose.maria@caf.com"
+        val password = "p@ssw0rd!#$%"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("Jos Mara", user.name)
+        assertEquals("jose.maria@caf.com", user.email)
+        assertEquals("p@ssw0rd!#$%", user.password)
+    }
+
+    @Test
+    fun `user creation with long strings`() {
+        // Given
+        val name = "A".repeat(1000)
+        val email = "test@example.com"
+        val password = "B".repeat(1000)
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("A".repeat(1000), user.name)
+        assertEquals("test@example.com", user.email)
+        assertEquals("B".repeat(1000), user.password)
+    }
+
+    @Test
+    fun `user equality with same data`() {
+        // Given
+        val user1 = User("John Doe", "john@example.com", "password123")
+        val user2 = User("John Doe", "john@example.com", "password123")
+
+        // When & Then
+        assertEquals(user1, user2)
+        assertEquals(user1.hashCode(), user2.hashCode())
+    }
+
+    @Test
+    fun `user equality with different data`() {
+        // Given
+        val user1 = User("John Doe", "john@example.com", "password123")
+        val user2 = User("Jane Doe", "jane@example.com", "password456")
+
+        // When & Then
+        assertNotEquals(user1, user2)
+        assertNotEquals(user1.hashCode(), user2.hashCode())
+    }
+
+    @Test
+    fun `user equality with different name`() {
+        // Given
+        val user1 = User("John Doe", "john@example.com", "password123")
+        val user2 = User("Jane Doe", "john@example.com", "password123")
+
+        // When & Then
+        assertNotEquals(user1, user2)
+    }
+
+    @Test
+    fun `user equality with different email`() {
+        // Given
+        val user1 = User("John Doe", "john@example.com", "password123")
+        val user2 = User("John Doe", "jane@example.com", "password123")
+
+        // When & Then
+        assertNotEquals(user1, user2)
+    }
+
+    @Test
+    fun `user equality with different password`() {
+        // Given
+        val user1 = User("John Doe", "john@example.com", "password123")
+        val user2 = User("John Doe", "john@example.com", "password456")
+
+        // When & Then
+        assertNotEquals(user1, user2)
+    }
+
+    @Test
+    fun `user copy with new name`() {
+        // Given
+        val originalUser = User("John Doe", "john@example.com", "password123")
+
+        // When
+        val copiedUser = originalUser.copy(name = "Jane Doe")
+
+        // Then
+        assertEquals("Jane Doe", copiedUser.name)
+        assertEquals("john@example.com", copiedUser.email)
+        assertEquals("password123", copiedUser.password)
+        assertNotEquals(originalUser, copiedUser)
+    }
+
+    @Test
+    fun `user copy with new email`() {
+        // Given
+        val originalUser = User("John Doe", "john@example.com", "password123")
+
+        // When
+        val copiedUser = originalUser.copy(email = "jane@example.com")
+
+        // Then
+        assertEquals("John Doe", copiedUser.name)
+        assertEquals("jane@example.com", copiedUser.email)
+        assertEquals("password123", copiedUser.password)
+        assertNotEquals(originalUser, copiedUser)
+    }
+
+    @Test
+    fun `user copy with new password`() {
+        // Given
+        val originalUser = User("John Doe", "john@example.com", "password123")
+
+        // When
+        val copiedUser = originalUser.copy(password = "newpassword456")
+
+        // Then
+        assertEquals("John Doe", copiedUser.name)
+        assertEquals("john@example.com", copiedUser.email)
+        assertEquals("newpassword456", copiedUser.password)
+        assertNotEquals(originalUser, copiedUser)
+    }
+
+    @Test
+    fun `user copy with all new values`() {
+        // Given
+        val originalUser = User("John Doe", "john@example.com", "password123")
+
+        // When
+        val copiedUser = originalUser.copy(
+            name = "Jane Smith",
+            email = "jane.smith@example.com",
+            password = "newpassword789"
+        )
+
+        // Then
+        assertEquals("Jane Smith", copiedUser.name)
+        assertEquals("jane.smith@example.com", copiedUser.email)
+        assertEquals("newpassword789", copiedUser.password)
+        assertNotEquals(originalUser, copiedUser)
+    }
+
+    @Test
+    fun `user copy with no changes`() {
+        // Given
+        val originalUser = User("John Doe", "john@example.com", "password123")
+
+        // When
+        val copiedUser = originalUser.copy()
+
+        // Then
+        assertEquals(originalUser, copiedUser)
+        assertEquals(originalUser.hashCode(), copiedUser.hashCode())
+    }
+
+    @Test
+    fun `user toString contains all fields`() {
+        // Given
+        val user = User("John Doe", "john@example.com", "password123")
+
+        // When
+        val userString = user.toString()
+
+        // Then
+        assertTrue(userString.contains("John Doe"))
+        assertTrue(userString.contains("john@example.com"))
+        assertTrue(userString.contains("password123"))
+    }
+
+    @Test
+    fun `user with email containing numbers`() {
+        // Given
+        val name = "User123"
+        val email = "user123@example123.com"
+        val password = "pass123"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("User123", user.name)
+        assertEquals("user123@example123.com", user.email)
+        assertEquals("pass123", user.password)
+    }
+
+    @Test
+    fun `user with email containing underscores and dots`() {
+        // Given
+        val name = "Test User"
+        val email = "test.user_name@sub.domain.com"
+        val password = "test_password"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("Test User", user.name)
+        assertEquals("test.user_name@sub.domain.com", user.email)
+        assertEquals("test_password", user.password)
+    }
+
+    @Test
+    fun `user with unicode characters`() {
+        // Given
+        val name = ""
+        val email = "test@.com"
+        val password = "123"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("", user.name)
+        assertEquals("test@.com", user.email)
+        assertEquals("123", user.password)
+    }
+
+    @Test
+    fun `user with whitespace in name`() {
+        // Given
+        val name = "  John Doe  "
+        val email = "john@example.com"
+        val password = "password123"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("  John Doe  ", user.name)
+        assertEquals("john@example.com", user.email)
+        assertEquals("password123", user.password)
+    }
+
+    @Test
+    fun `user with whitespace in email`() {
+        // Given
+        val name = "John Doe"
+        val email = "  john@example.com  "
+        val password = "password123"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("John Doe", user.name)
+        assertEquals("  john@example.com  ", user.email)
+        assertEquals("password123", user.password)
+    }
+
+    @Test
+    fun `user with whitespace in password`() {
+        // Given
+        val name = "John Doe"
+        val email = "john@example.com"
+        val password = "  password123  "
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("John Doe", user.name)
+        assertEquals("john@example.com", user.email)
+        assertEquals("  password123  ", user.password)
+    }
+
+    @Test
+    fun `user with newline characters`() {
+        // Given
+        val name = "John\nDoe"
+        val email = "john@example.com"
+        val password = "pass\nword"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("John\nDoe", user.name)
+        assertEquals("john@example.com", user.email)
+        assertEquals("pass\nword", user.password)
+    }
+
+    @Test
+    fun `user with tab characters`() {
+        // Given
+        val name = "John\tDoe"
+        val email = "john@example.com"
+        val password = "pass\tword"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("John\tDoe", user.name)
+        assertEquals("john@example.com", user.email)
+        assertEquals("pass\tword", user.password)
+    }
+
+    @Test
+    fun `user with case sensitive data`() {
+        // Given
+        val name = "John Doe"
+        val email = "John.Doe@Example.COM"
+        val password = "Password123"
+
+        // When
+        val user = User(name, email, password)
+
+        // Then
+        assertEquals("John Doe", user.name)
+        assertEquals("John.Doe@Example.COM", user.email)
+        assertEquals("Password123", user.password)
+    }
+
+    @Test
+    fun `user equality case sensitivity`() {
+        // Given
+        val user1 = User("John Doe", "john@example.com", "password123")
+        val user2 = User("john doe", "JOHN@EXAMPLE.COM", "PASSWORD123")
+
+        // When & Then
+        assertNotEquals(user1, user2)
+    }
+}
diff --git a/app/src/test/java/com/example/cocktailsdbapp/repository/CocktailsRepoImplTest.kt b/app/src/test/java/com/example/cocktailsdbapp/repository/CocktailsRepoImplTest.kt
new file mode 100644
index 0000000..a0f48a6
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/repository/CocktailsRepoImplTest.kt
@@ -0,0 +1,506 @@
+package com.example.cocktailsdbapp.repository
+
+import com.example.cocktailsdbapp.database.CocktailDao
+import com.example.cocktailsdbapp.database.RoomCocktail
+import com.example.cocktailsdbapp.database.RoomFavorite
+import com.example.cocktailsdbapp.model.*
+import com.example.cocktailsdbapp.network.CocktailApiService
+import io.mockk.*
+import kotlinx.coroutines.test.runTest
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for CocktailsRepoImpl
+ */
+class CocktailsRepoImplTest {
+
+    private lateinit var repository: CocktailsRepoImpl
+    private lateinit var mockApiService: CocktailApiService
+    private lateinit var mockCocktailDao: CocktailDao
+
+    @Before
+    fun setup() {
+        mockApiService = mockk()
+        mockCocktailDao = mockk()
+        repository = CocktailsRepoImpl(mockApiService, mockCocktailDao)
+    }
+
+    @After
+    fun tearDown() {
+        clearAllMocks()
+    }
+
+    @Test
+    fun `getCocktailsByAlcoholContent returns response from API`() = runTest {
+        // Given
+        val alcoholContent = "Alcoholic"
+        val expectedResponse = CocktailResponse(
+            drinks = listOf(
+                Cocktail("Mojito", "mojito.jpg", "11007")
+            )
+        )
+        coEvery { mockApiService.getCocktailsByAlcoholContent(alcoholContent) } returns expectedResponse
+
+        // When
+        val result = repository.getCocktailsByAlcoholContent(alcoholContent)
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals(1, result.drinks?.size)
+        assertEquals("Mojito", result.drinks?.first()?.strDrink)
+        coVerify(exactly = 1) { mockApiService.getCocktailsByAlcoholContent(alcoholContent) }
+    }
+
+    @Test
+    fun `getCocktailsByGlass returns response from API`() = runTest {
+        // Given
+        val glass = "Highball glass"
+        val expectedResponse = CocktailResponse(
+            drinks = listOf(
+                Cocktail("Mojito", "mojito.jpg", "11007")
+            )
+        )
+        coEvery { mockApiService.getCocktailsByGlass(glass) } returns expectedResponse
+
+        // When
+        val result = repository.getCocktailsByGlass(glass)
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals("Mojito", result.drinks?.first()?.strDrink)
+        coVerify(exactly = 1) { mockApiService.getCocktailsByGlass(glass) }
+    }
+
+    @Test
+    fun `getCocktailsByCategory returns response from API`() = runTest {
+        // Given
+        val category = "Cocktail"
+        val expectedResponse = CocktailResponse(
+            drinks = listOf(
+                Cocktail("Margarita", "margarita.jpg", "11008")
+            )
+        )
+        coEvery { mockApiService.getCocktailsByCategory(category) } returns expectedResponse
+
+        // When
+        val result = repository.getCocktailsByCategory(category)
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals("Margarita", result.drinks?.first()?.strDrink)
+        coVerify(exactly = 1) { mockApiService.getCocktailsByCategory(category) }
+    }
+
+    @Test
+    fun `getCocktailsByFirstLetter returns response from API`() = runTest {
+        // Given
+        val letter = "m"
+        val expectedResponse = CocktailResponse(
+            drinks = listOf(
+                Cocktail("Mojito", "mojito.jpg", "11007"),
+                Cocktail("Margarita", "margarita.jpg", "11008")
+            )
+        )
+        coEvery { mockApiService.getCocktailsByFirstLetter(letter) } returns expectedResponse
+
+        // When
+        val result = repository.getCocktailsByFirstLetter(letter)
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals(2, result.drinks?.size)
+        coVerify(exactly = 1) { mockApiService.getCocktailsByFirstLetter(letter) }
+    }
+
+    @Test
+    fun `getCocktailsByIngredient returns response from API`() = runTest {
+        // Given
+        val ingredient = "Vodka"
+        val expectedResponse = CocktailResponse(
+            drinks = listOf(
+                Cocktail("Martini", "martini.jpg", "11009")
+            )
+        )
+        coEvery { mockApiService.getCocktailsByIngredient(ingredient) } returns expectedResponse
+
+        // When
+        val result = repository.getCocktailsByIngredient(ingredient)
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals("Martini", result.drinks?.first()?.strDrink)
+        coVerify(exactly = 1) { mockApiService.getCocktailsByIngredient(ingredient) }
+    }
+
+    @Test
+    fun `getAlcoholContent returns response from API`() = runTest {
+        // Given
+        val expectedResponse = AlcoholContentResponse(
+            drinks = listOf(
+                AlcoholContent("Alcoholic"),
+                AlcoholContent("Non alcoholic")
+            )
+        )
+        coEvery { mockApiService.getAlcoholContent() } returns expectedResponse
+
+        // When
+        val result = repository.getAlcoholContent()
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals(2, result.drinks.size)
+        coVerify(exactly = 1) { mockApiService.getAlcoholContent() }
+    }
+
+    @Test
+    fun `getCategories returns response from API`() = runTest {
+        // Given
+        val expectedResponse = FilterResponse(
+            drinks = listOf(
+                DrinkCategory("Cocktail"),
+                DrinkCategory("Shot")
+            )
+        )
+        coEvery { mockApiService.getCategories() } returns expectedResponse
+
+        // When
+        val result = repository.getCategories()
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals(2, result.drinks.size)
+        coVerify(exactly = 1) { mockApiService.getCategories() }
+    }
+
+    @Test
+    fun `getGlasses returns response from API`() = runTest {
+        // Given
+        val expectedResponse = GlassesResponse(
+            drinks = listOf(
+                Glass("Highball glass"),
+                Glass("Cocktail glass")
+            )
+        )
+        coEvery { mockApiService.getGlasses() } returns expectedResponse
+
+        // When
+        val result = repository.getGlasses()
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals(2, result.drinks.size)
+        coVerify(exactly = 1) { mockApiService.getGlasses() }
+    }
+
+    @Test
+    fun `getIngredients returns response from API`() = runTest {
+        // Given
+        val expectedResponse = IngredientListResponse(
+            drinks = listOf(
+                StrIngredient("Vodka"),
+                StrIngredient("Gin")
+            )
+        )
+        coEvery { mockApiService.getIngredients() } returns expectedResponse
+
+        // When
+        val result = repository.getIngredients()
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals(2, result.drinks.size)
+        coVerify(exactly = 1) { mockApiService.getIngredients() }
+    }
+
+    @Test
+    fun `getCocktailDetails returns response from API`() = runTest {
+        // Given
+        val cocktailId = "11007"
+        val cocktailDetails = CocktailDetails(
+            idDrink = "11007",
+            strDrink = "Mojito",
+            strDrinkAlternate = null,
+            strTags = null,
+            strVideo = null,
+            strCategory = "Cocktail",
+            strIBA = null,
+            strAlcoholic = "Alcoholic",
+            strGlass = "Highball glass",
+            strInstructions = "Mix ingredients",
+            strInstructionsES = null,
+            strInstructionsDE = null,
+            strInstructionsFR = null,
+            strInstructionsIT = null,
+            strInstructionsZH_HANS = null,
+            strInstructionsZH_HANT = null,
+            strDrinkThumb = "mojito.jpg",
+            strIngredient1 = "Rum",
+            strIngredient2 = "Lime",
+            strIngredient3 = null,
+            strIngredient4 = null,
+            strIngredient5 = null,
+            strIngredient6 = null,
+            strIngredient7 = null,
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = "2 oz",
+            strMeasure2 = "1 oz",
+            strMeasure3 = null,
+            strMeasure4 = null,
+            strMeasure5 = null,
+            strMeasure6 = null,
+            strMeasure7 = null,
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = null,
+            strImageAttribution = null,
+            strCreativeCommonsConfirmed = null,
+            dateModified = null,
+            isFavorite = false
+        )
+        val expectedResponse = CocktailDetailsResponse(drinks = listOf(cocktailDetails))
+        coEvery { mockApiService.getCocktailDetails(cocktailId) } returns expectedResponse
+
+        // When
+        val result = repository.getCocktailDetails(cocktailId)
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertEquals("Mojito", result.drinks?.first()?.strDrink)
+        coVerify(exactly = 1) { mockApiService.getCocktailDetails(cocktailId) }
+    }
+
+    @Test
+    fun `getSearch returns transformed response from API`() = runTest {
+        // Given
+        val searchParam = "mojito"
+        val cocktailDetails = CocktailDetails(
+            idDrink = "11007",
+            strDrink = "Mojito",
+            strDrinkAlternate = null,
+            strTags = null,
+            strVideo = null,
+            strCategory = null,
+            strIBA = null,
+            strAlcoholic = null,
+            strGlass = null,
+            strInstructions = null,
+            strInstructionsES = null,
+            strInstructionsDE = null,
+            strInstructionsFR = null,
+            strInstructionsIT = null,
+            strInstructionsZH_HANS = null,
+            strInstructionsZH_HANT = null,
+            strDrinkThumb = "mojito.jpg",
+            strIngredient1 = null,
+            strIngredient2 = null,
+            strIngredient3 = null,
+            strIngredient4 = null,
+            strIngredient5 = null,
+            strIngredient6 = null,
+            strIngredient7 = null,
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = null,
+            strMeasure2 = null,
+            strMeasure3 = null,
+            strMeasure4 = null,
+            strMeasure5 = null,
+            strMeasure6 = null,
+            strMeasure7 = null,
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = null,
+            strImageAttribution = null,
+            strCreativeCommonsConfirmed = null,
+            dateModified = null,
+            isFavorite = false
+        )
+        val apiResponse = CocktailDetailsResponse(drinks = listOf(cocktailDetails))
+        coEvery { mockApiService.getSearch(searchParam) } returns apiResponse
+
+        // When
+        val result = repository.getSearch(searchParam)
+
+        // Then
+        assertNotNull(result)
+        assertEquals(1, result.drinks?.size)
+        coVerify(exactly = 1) { mockApiService.getSearch(searchParam) }
+    }
+
+    @Test
+    fun `getFavorites returns favorites from database`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val expectedFavorites = listOf(
+            RoomCocktail("Mojito", "mojito.jpg", "11007"),
+            RoomCocktail("Margarita", "margarita.jpg", "11008")
+        )
+        coEvery { mockCocktailDao.getFavoriteCocktails(userEmail) } returns expectedFavorites
+
+        // When
+        val result = repository.getFavorites(userEmail)
+
+        // Then
+        assertEquals(expectedFavorites, result)
+        assertEquals(2, result?.size)
+        assertEquals("Mojito", result?.first()?.strDrink)
+        coVerify(exactly = 1) { mockCocktailDao.getFavoriteCocktails(userEmail) }
+    }
+
+    @Test
+    fun `getFavorites returns null when no favorites`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        coEvery { mockCocktailDao.getFavoriteCocktails(userEmail) } returns null
+
+        // When
+        val result = repository.getFavorites(userEmail)
+
+        // Then
+        assertNull(result)
+        coVerify(exactly = 1) { mockCocktailDao.getFavoriteCocktails(userEmail) }
+    }
+
+    @Test
+    fun `findFavoriteCocktail returns cocktail from database`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktailId = "11007"
+        val expectedCocktail = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        coEvery { mockCocktailDao.findFavoriteCocktail(userEmail, cocktailId) } returns expectedCocktail
+
+        // When
+        val result = repository.findFavoriteCocktail(userEmail, cocktailId)
+
+        // Then
+        assertEquals(expectedCocktail, result)
+        assertEquals("Mojito", result?.strDrink)
+        coVerify(exactly = 1) { mockCocktailDao.findFavoriteCocktail(userEmail, cocktailId) }
+    }
+
+    @Test
+    fun `findFavoriteCocktail returns null when not found`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktailId = "11007"
+        coEvery { mockCocktailDao.findFavoriteCocktail(userEmail, cocktailId) } returns null
+
+        // When
+        val result = repository.findFavoriteCocktail(userEmail, cocktailId)
+
+        // Then
+        assertNull(result)
+        coVerify(exactly = 1) { mockCocktailDao.findFavoriteCocktail(userEmail, cocktailId) }
+    }
+
+    @Test
+    fun `removeFavorite calls dao removeFavorite`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktailId = "11007"
+        coEvery { mockCocktailDao.removeFavorite(userEmail, cocktailId) } just Runs
+
+        // When
+        repository.removeFavorite(userEmail, cocktailId)
+
+        // Then
+        coVerify(exactly = 1) { mockCocktailDao.removeFavorite(userEmail, cocktailId) }
+    }
+
+    @Test
+    fun `insertCocktail inserts cocktail and favorite to database`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val roomCocktail = RoomCocktail("Mojito", "mojito.jpg", "11007")
+        coEvery { mockCocktailDao.insertCocktail(roomCocktail) } just Runs
+        coEvery { mockCocktailDao.insertFavorite(any()) } just Runs
+
+        // When
+        repository.insertCocktail(userEmail, roomCocktail)
+
+        // Then
+        coVerify(exactly = 1) { mockCocktailDao.insertCocktail(roomCocktail) }
+        coVerify(exactly = 1) { 
+            mockCocktailDao.insertFavorite(
+                match { it.userEmail == userEmail && it.idDrink == "11007" }
+            ) 
+        }
+    }
+
+    @Test
+    fun `insertCocktail creates correct RoomFavorite`() = runTest {
+        // Given
+        val userEmail = "user@test.com"
+        val roomCocktail = RoomCocktail("Martini", "martini.jpg", "11009")
+        val capturedFavorite = slot<RoomFavorite>()
+        
+        coEvery { mockCocktailDao.insertCocktail(roomCocktail) } just Runs
+        coEvery { mockCocktailDao.insertFavorite(capture(capturedFavorite)) } just Runs
+
+        // When
+        repository.insertCocktail(userEmail, roomCocktail)
+
+        // Then
+        assertEquals(userEmail, capturedFavorite.captured.userEmail)
+        assertEquals("11009", capturedFavorite.captured.idDrink)
+    }
+
+    @Test
+    fun `getCocktailsByAlcoholContent handles empty response`() = runTest {
+        // Given
+        val alcoholContent = "Alcoholic"
+        val expectedResponse = CocktailResponse(drinks = emptyList())
+        coEvery { mockApiService.getCocktailsByAlcoholContent(alcoholContent) } returns expectedResponse
+
+        // When
+        val result = repository.getCocktailsByAlcoholContent(alcoholContent)
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertTrue(result.drinks?.isEmpty() == true)
+    }
+
+    @Test
+    fun `getCocktailsByAlcoholContent handles null response`() = runTest {
+        // Given
+        val alcoholContent = "Alcoholic"
+        val expectedResponse = CocktailResponse(drinks = null)
+        coEvery { mockApiService.getCocktailsByAlcoholContent(alcoholContent) } returns expectedResponse
+
+        // When
+        val result = repository.getCocktailsByAlcoholContent(alcoholContent)
+
+        // Then
+        assertEquals(expectedResponse, result)
+        assertNull(result.drinks)
+    }
+}
+
diff --git a/app/src/test/java/com/example/cocktailsdbapp/ui/authorization/AuthViewModelTest.kt b/app/src/test/java/com/example/cocktailsdbapp/ui/authorization/AuthViewModelTest.kt
new file mode 100644
index 0000000..0c12947
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/ui/authorization/AuthViewModelTest.kt
@@ -0,0 +1,550 @@
+package com.example.cocktailsdbapp.ui.authorization
+
+import android.content.SharedPreferences
+import com.example.cocktailsdbapp.model.User
+import com.example.cocktailsdbapp.utils.Constants
+import io.mockk.*
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for AuthViewModel
+ */
+class AuthViewModelTest {
+
+    private lateinit var viewModel: AuthViewModel
+    private lateinit var mockSharedPreferences: SharedPreferences
+    private lateinit var mockEditor: SharedPreferences.Editor
+
+    @Before
+    fun setup() {
+        mockSharedPreferences = mockk()
+        mockEditor = mockk()
+        viewModel = AuthViewModel(mockSharedPreferences)
+        
+        every { mockSharedPreferences.edit() } returns mockEditor
+        every { mockEditor.putString(any(), any()) } returns mockEditor
+        every { mockEditor.apply() } just Runs
+    }
+
+    @After
+    fun tearDown() {
+        clearAllMocks()
+    }
+
+    @Test
+    fun `saveUserData with new user returns true and saves data`() {
+        // Given
+        val user = User("John Doe", "john@example.com", "password123")
+
+        // When
+        val result = viewModel.saveUserData(user)
+
+        // Then
+        assertTrue(result)
+        verify {
+            mockEditor.putString("${user.email}${Constants.SHARED_PREF_NAME}", user.name)
+            mockEditor.putString("${user.email}${Constants.SHARED_PREF_EMAIL}", user.email)
+            mockEditor.putString("${user.email}${Constants.SHARED_PREF_PASSWORD}", user.password)
+            mockEditor.apply()
+        }
+    }
+
+    @Test
+    fun `saveUserData with existing user returns false`() {
+        // Given
+        val user = User("John Doe", "john@example.com", "password123")
+        viewModel.saveUserData(user) // First save
+
+        // When
+        val result = viewModel.saveUserData(user) // Second save
+
+        // Then
+        assertFalse(result)
+        verify(exactly = 1) { mockEditor.apply() } // Only called once
+    }
+
+    @Test
+    fun `saveUserData with different users with same email returns false`() {
+        // Given
+        val user1 = User("John Doe", "john@example.com", "password123")
+        val user2 = User("Jane Doe", "john@example.com", "password456")
+        viewModel.saveUserData(user1) // First save
+
+        // When
+        val result = viewModel.saveUserData(user2) // Second save with same email
+
+        // Then
+        assertFalse(result)
+        verify(exactly = 1) { mockEditor.apply() } // Only called once
+    }
+
+    @Test
+    fun `saveUserData with different emails saves both users`() {
+        // Given
+        val user1 = User("John Doe", "john@example.com", "password123")
+        val user2 = User("Jane Doe", "jane@example.com", "password456")
+
+        // When
+        val result1 = viewModel.saveUserData(user1)
+        val result2 = viewModel.saveUserData(user2)
+
+        // Then
+        assertTrue(result1)
+        assertTrue(result2)
+        verify(exactly = 2) { mockEditor.apply() }
+    }
+
+    @Test
+    fun `getUserData returns correct user data`() {
+        // Given
+        val email = "john@example.com"
+        val name = "John Doe"
+        val password = "password123"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns name
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns password
+
+        // When
+        val result = viewModel.getUserData(email)
+
+        // Then
+        assertEquals(name, result.name)
+        assertEquals(email, result.email)
+        assertEquals(password, result.password)
+    }
+
+    @Test
+    fun `getUserData with non-existent user returns empty strings`() {
+        // Given
+        val email = "nonexistent@example.com"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns ""
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns ""
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns ""
+
+        // When
+        val result = viewModel.getUserData(email)
+
+        // Then
+        assertEquals("", result.name)
+        assertEquals("", result.email)
+        assertEquals("", result.password)
+    }
+
+    @Test
+    fun `getUserData with null values returns empty strings`() {
+        // Given
+        val email = "john@example.com"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns null
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns null
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns null
+
+        // When
+        val result = viewModel.getUserData(email)
+
+        // Then
+        assertEquals("", result.name)
+        assertEquals("", result.email)
+        assertEquals("", result.password)
+    }
+
+    @Test
+    fun `isUserInfoValid with correct credentials returns true`() {
+        // Given
+        val email = "john@example.com"
+        val password = "password123"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns password
+
+        // When
+        val result = viewModel.isUserInfoValid(email, password)
+
+        // Then
+        assertTrue(result)
+    }
+
+    @Test
+    fun `isUserInfoValid with incorrect password returns false`() {
+        // Given
+        val email = "john@example.com"
+        val correctPassword = "password123"
+        val wrongPassword = "wrongpassword"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns correctPassword
+
+        // When
+        val result = viewModel.isUserInfoValid(email, wrongPassword)
+
+        // Then
+        assertFalse(result)
+    }
+
+    @Test
+    fun `isUserInfoValid with non-existent email returns false`() {
+        // Given
+        val email = "nonexistent@example.com"
+        val password = "password123"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns ""
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns ""
+
+        // When
+        val result = viewModel.isUserInfoValid(email, password)
+
+        // Then
+        assertFalse(result)
+    }
+
+    @Test
+    fun `isUserInfoValid with null email returns false`() {
+        // Given
+        val email = "john@example.com"
+        val password = "password123"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns null
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns password
+
+        // When
+        val result = viewModel.isUserInfoValid(email, password)
+
+        // Then
+        assertFalse(result)
+    }
+
+    @Test
+    fun `editUserName updates name correctly`() {
+        // Given
+        val email = "john@example.com"
+        val oldName = "John Doe"
+        val newName = "John Smith"
+        val password = "password123"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns oldName
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns password
+
+        // When
+        viewModel.editUserName(email, newName)
+
+        // Then
+        verify {
+            mockEditor.putString("${email}${Constants.SHARED_PREF_NAME}", newName)
+            mockEditor.apply()
+        }
+    }
+
+    @Test
+    fun `editUserName with empty name updates correctly`() {
+        // Given
+        val email = "john@example.com"
+        val oldName = "John Doe"
+        val newName = ""
+        val password = "password123"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns oldName
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns password
+
+        // When
+        viewModel.editUserName(email, newName)
+
+        // Then
+        verify {
+            mockEditor.putString("${email}${Constants.SHARED_PREF_NAME}", newName)
+            mockEditor.apply()
+        }
+    }
+
+    @Test
+    fun `editPassword updates password correctly`() {
+        // Given
+        val email = "john@example.com"
+        val name = "John Doe"
+        val oldPassword = "password123"
+        val newPassword = "newpassword456"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns name
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns oldPassword
+
+        // When
+        viewModel.editPassword(email, newPassword)
+
+        // Then
+        verify {
+            mockEditor.putString("${email}${Constants.SHARED_PREF_PASSWORD}", newPassword)
+            mockEditor.apply()
+        }
+    }
+
+    @Test
+    fun `editPassword with empty password updates correctly`() {
+        // Given
+        val email = "john@example.com"
+        val name = "John Doe"
+        val oldPassword = "password123"
+        val newPassword = ""
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns name
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns oldPassword
+
+        // When
+        viewModel.editPassword(email, newPassword)
+
+        // Then
+        verify {
+            mockEditor.putString("${email}${Constants.SHARED_PREF_PASSWORD}", newPassword)
+            mockEditor.apply()
+        }
+    }
+
+    @Test
+    fun `editUserName with special characters updates correctly`() {
+        // Given
+        val email = "john@example.com"
+        val oldName = "John Doe"
+        val newName = "Jos Mara"
+        val password = "password123"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns oldName
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns password
+
+        // When
+        viewModel.editUserName(email, newName)
+
+        // Then
+        verify {
+            mockEditor.putString("${email}${Constants.SHARED_PREF_NAME}", newName)
+            mockEditor.apply()
+        }
+    }
+
+    @Test
+    fun `editPassword with special characters updates correctly`() {
+        // Given
+        val email = "john@example.com"
+        val name = "John Doe"
+        val oldPassword = "password123"
+        val newPassword = "p@ssw0rd!#$%"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns name
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns oldPassword
+
+        // When
+        viewModel.editPassword(email, newPassword)
+
+        // Then
+        verify {
+            mockEditor.putString("${email}${Constants.SHARED_PREF_PASSWORD}", newPassword)
+            mockEditor.apply()
+        }
+    }
+
+    @Test
+    fun `saveUserData with empty strings saves correctly`() {
+        // Given
+        val user = User("", "", "")
+
+        // When
+        val result = viewModel.saveUserData(user)
+
+        // Then
+        assertTrue(result)
+        verify {
+            mockEditor.putString("${user.email}${Constants.SHARED_PREF_NAME}", user.name)
+            mockEditor.putString("${user.email}${Constants.SHARED_PREF_EMAIL}", user.email)
+            mockEditor.putString("${user.email}${Constants.SHARED_PREF_PASSWORD}", user.password)
+            mockEditor.apply()
+        }
+    }
+
+    @Test
+    fun `saveUserData with long strings saves correctly`() {
+        // Given
+        val user = User("A".repeat(1000), "test@example.com", "B".repeat(1000))
+
+        // When
+        val result = viewModel.saveUserData(user)
+
+        // Then
+        assertTrue(result)
+        verify {
+            mockEditor.putString("${user.email}${Constants.SHARED_PREF_NAME}", user.name)
+            mockEditor.putString("${user.email}${Constants.SHARED_PREF_EMAIL}", user.email)
+            mockEditor.putString("${user.email}${Constants.SHARED_PREF_PASSWORD}", user.password)
+            mockEditor.apply()
+        }
+    }
+
+    @Test
+    fun `isUserInfoValid with case sensitive password`() {
+        // Given
+        val email = "john@example.com"
+        val storedPassword = "Password123"
+        val inputPassword = "password123"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns storedPassword
+
+        // When
+        val result = viewModel.isUserInfoValid(email, inputPassword)
+
+        // Then
+        assertFalse(result) // Case sensitive
+    }
+
+    @Test
+    fun `isUserInfoValid with exact case match returns true`() {
+        // Given
+        val email = "john@example.com"
+        val storedPassword = "Password123"
+        val inputPassword = "Password123"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns storedPassword
+
+        // When
+        val result = viewModel.isUserInfoValid(email, inputPassword)
+
+        // Then
+        assertTrue(result)
+    }
+
+    @Test
+    fun `multiple saveUserData calls with different users`() {
+        // Given
+        val user1 = User("John Doe", "john@example.com", "password123")
+        val user2 = User("Jane Smith", "jane@example.com", "password456")
+        val user3 = User("Bob Johnson", "bob@example.com", "password789")
+
+        // When
+        val result1 = viewModel.saveUserData(user1)
+        val result2 = viewModel.saveUserData(user2)
+        val result3 = viewModel.saveUserData(user3)
+
+        // Then
+        assertTrue(result1)
+        assertTrue(result2)
+        assertTrue(result3)
+        verify(exactly = 3) { mockEditor.apply() }
+    }
+
+    @Test
+    fun `editUserName and editPassword with same user`() {
+        // Given
+        val email = "john@example.com"
+        val name = "John Doe"
+        val oldPassword = "password123"
+        val newName = "John Smith"
+        val newPassword = "newpassword456"
+        
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_NAME}", "") 
+        } returns name
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_EMAIL}", "") 
+        } returns email
+        every { 
+            mockSharedPreferences.getString("${email}${Constants.SHARED_PREF_PASSWORD}", "") 
+        } returns oldPassword
+
+        // When
+        viewModel.editUserName(email, newName)
+        viewModel.editPassword(email, newPassword)
+
+        // Then
+        verify {
+            mockEditor.putString("${email}${Constants.SHARED_PREF_NAME}", newName)
+            mockEditor.putString("${email}${Constants.SHARED_PREF_PASSWORD}", newPassword)
+        }
+        verify(exactly = 2) { mockEditor.apply() }
+    }
+}
diff --git a/app/src/test/java/com/example/cocktailsdbapp/ui/category/FilterViewModelTest.kt b/app/src/test/java/com/example/cocktailsdbapp/ui/category/FilterViewModelTest.kt
new file mode 100644
index 0000000..fc3e750
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/ui/category/FilterViewModelTest.kt
@@ -0,0 +1,391 @@
+package com.example.cocktailsdbapp.ui.category
+
+import androidx.arch.core.executor.testing.InstantTaskExecutorRule
+import com.example.cocktailsdbapp.model.AlcoholContentResponse
+import com.example.cocktailsdbapp.model.FilterResponse
+import com.example.cocktailsdbapp.model.GlassesResponse
+import com.example.cocktailsdbapp.model.IngredientListResponse
+import com.example.cocktailsdbapp.repository.CocktailsRepo
+import com.example.cocktailsdbapp.utils.Constants
+import io.mockk.*
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.*
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for FilterViewModel
+ */
+@OptIn(ExperimentalCoroutinesApi::class)
+class FilterViewModelTest {
+
+    @get:Rule
+    val instantTaskExecutorRule = InstantTaskExecutorRule()
+
+    private lateinit var viewModel: FilterViewModel
+    private lateinit var mockRepo: CocktailsRepo
+    private val testDispatcher = StandardTestDispatcher()
+
+    @Before
+    fun setup() {
+        mockRepo = mockk()
+        viewModel = FilterViewModel(mockRepo)
+        Dispatchers.setMain(testDispatcher)
+    }
+
+    @After
+    fun tearDown() {
+        clearAllMocks()
+        Dispatchers.resetMain()
+    }
+
+    @Test
+    fun `fetchData with FILTER_ALCOHOL calls getAlcoholContent`() = runTest {
+        // Given
+        val alcoholContentResponse = AlcoholContentResponse(
+            drinks = listOf(
+                com.example.cocktailsdbapp.model.AlcoholContent(strAlcoholic = "Alcoholic"),
+                com.example.cocktailsdbapp.model.AlcoholContent(strAlcoholic = "Non alcoholic"),
+                com.example.cocktailsdbapp.model.AlcoholContent(strAlcoholic = "Optional alcohol")
+            )
+        )
+
+        coEvery { mockRepo.getAlcoholContent() } returns alcoholContentResponse
+
+        // When
+        viewModel.fetchData(Constants.FILTER_ALCOHOL)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getAlcoholContent() }
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertEquals(3, result?.size)
+        assertTrue(result?.contains("Alcoholic") == true)
+        assertTrue(result?.contains("Non alcoholic") == true)
+        assertTrue(result?.contains("Optional alcohol") == true)
+    }
+
+    @Test
+    fun `fetchData with FILTER_CATEGORY calls getCategories`() = runTest {
+        // Given
+        val categoryResponse = FilterResponse(
+            drinks = listOf(
+                com.example.cocktailsdbapp.model.DrinkCategory(strCategory = "Cocktail"),
+                com.example.cocktailsdbapp.model.DrinkCategory(strCategory = "Ordinary Drink"),
+                com.example.cocktailsdbapp.model.DrinkCategory(strCategory = "Shot")
+            )
+        )
+
+        coEvery { mockRepo.getCategories() } returns categoryResponse
+
+        // When
+        viewModel.fetchData(Constants.FILTER_CATEGORY)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCategories() }
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertEquals(3, result?.size)
+        assertTrue(result?.contains("Cocktail") == true)
+        assertTrue(result?.contains("Ordinary Drink") == true)
+        assertTrue(result?.contains("Shot") == true)
+    }
+
+    @Test
+    fun `fetchData with FILTER_GLASS calls getGlasses`() = runTest {
+        // Given
+        val glassResponse = GlassesResponse(
+            drinks = listOf(
+                com.example.cocktailsdbapp.model.Glass(strGlass = "Highball glass"),
+                com.example.cocktailsdbapp.model.Glass(strGlass = "Cocktail glass"),
+                com.example.cocktailsdbapp.model.Glass(strGlass = "Shot glass")
+            )
+        )
+
+        coEvery { mockRepo.getGlasses() } returns glassResponse
+
+        // When
+        viewModel.fetchData(Constants.FILTER_GLASS)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getGlasses() }
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertEquals(3, result?.size)
+        assertTrue(result?.contains("Highball glass") == true)
+        assertTrue(result?.contains("Cocktail glass") == true)
+        assertTrue(result?.contains("Shot glass") == true)
+    }
+
+    @Test
+    fun `fetchData with FILTER_INGREDIENT calls getIngredients`() = runTest {
+        // Given
+        val ingredientResponse = IngredientListResponse(
+            drinks = listOf(
+                com.example.cocktailsdbapp.model.StrIngredient(strIngredient = "Vodka"),
+                com.example.cocktailsdbapp.model.StrIngredient(strIngredient = "Gin"),
+                com.example.cocktailsdbapp.model.StrIngredient(strIngredient = "Rum")
+            )
+        )
+
+        coEvery { mockRepo.getIngredients() } returns ingredientResponse
+
+        // When
+        viewModel.fetchData(Constants.FILTER_INGREDIENT)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getIngredients() }
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertEquals(3, result?.size)
+        assertTrue(result?.contains("Vodka") == true)
+        assertTrue(result?.contains("Gin") == true)
+        assertTrue(result?.contains("Rum") == true)
+    }
+
+    @Test
+    fun `fetchData with FILTER_LETTER returns alphabet letters`() = runTest {
+        // When
+        viewModel.fetchData(Constants.FILTER_LETTER)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertEquals(26, result?.size) // A to Z
+        assertEquals("A", result?.first())
+        assertEquals("Z", result?.last())
+        assertTrue(result?.contains("M") == true)
+        assertTrue(result?.contains("X") == true)
+    }
+
+    @Test
+    fun `fetchData with unknown filter type does nothing`() = runTest {
+        // When
+        viewModel.fetchData("Unknown Filter")
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        verify { mockRepo wasNot Called }
+        assertNull(viewModel.filterData.value)
+    }
+
+    @Test
+    fun `getAlcoholContent handles empty response`() = runTest {
+        // Given
+        val emptyResponse = AlcoholContentResponse(drinks = emptyList())
+
+        coEvery { mockRepo.getAlcoholContent() } returns emptyResponse
+
+        // When
+        viewModel.fetchData(Constants.FILTER_ALCOHOL)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getAlcoholContent() }
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertTrue(result?.isEmpty() == true)
+    }
+
+    @Test
+    fun `getCategories handles empty response`() = runTest {
+        // Given
+        val emptyResponse = FilterResponse(drinks = emptyList())
+
+        coEvery { mockRepo.getCategories() } returns emptyResponse
+
+        // When
+        viewModel.fetchData(Constants.FILTER_CATEGORY)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCategories() }
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertTrue(result?.isEmpty() == true)
+    }
+
+    @Test
+    fun `getGlasses handles empty response`() = runTest {
+        // Given
+        val emptyResponse = GlassesResponse(drinks = emptyList())
+
+        coEvery { mockRepo.getGlasses() } returns emptyResponse
+
+        // When
+        viewModel.fetchData(Constants.FILTER_GLASS)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getGlasses() }
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertTrue(result?.isEmpty() == true)
+    }
+
+    @Test
+    fun `getIngredients handles empty response`() = runTest {
+        // Given
+        val emptyResponse = IngredientListResponse(drinks = emptyList())
+
+        coEvery { mockRepo.getIngredients() } returns emptyResponse
+
+        // When
+        viewModel.fetchData(Constants.FILTER_INGREDIENT)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getIngredients() }
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertTrue(result?.isEmpty() == true)
+    }
+
+    @Test
+    fun `getAlcoholContent handles exception gracefully`() = runTest {
+        // Given
+        coEvery { mockRepo.getAlcoholContent() } throws Exception("Network error")
+
+        // When
+        viewModel.fetchData(Constants.FILTER_ALCOHOL)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Should not crash
+        coVerify { mockRepo.getAlcoholContent() }
+    }
+
+    @Test
+    fun `getCategories handles exception gracefully`() = runTest {
+        // Given
+        coEvery { mockRepo.getCategories() } throws Exception("Network error")
+
+        // When
+        viewModel.fetchData(Constants.FILTER_CATEGORY)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Should not crash
+        coVerify { mockRepo.getCategories() }
+    }
+
+    @Test
+    fun `getGlasses handles exception gracefully`() = runTest {
+        // Given
+        coEvery { mockRepo.getGlasses() } throws Exception("Network error")
+
+        // When
+        viewModel.fetchData(Constants.FILTER_GLASS)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Should not crash
+        coVerify { mockRepo.getGlasses() }
+    }
+
+    @Test
+    fun `getIngredients handles exception gracefully`() = runTest {
+        // Given
+        coEvery { mockRepo.getIngredients() } throws Exception("Network error")
+
+        // When
+        viewModel.fetchData(Constants.FILTER_INGREDIENT)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Should not crash
+        coVerify { mockRepo.getIngredients() }
+    }
+
+    @Test
+    fun `filterData is initialized`() {
+        // Then
+        assertNotNull(viewModel.filterData)
+    }
+
+    @Test
+    fun `fetchData with multiple calls updates data correctly`() = runTest {
+        // Given
+        val alcoholResponse = AlcoholContentResponse(
+            drinks = listOf(
+                com.example.cocktailsdbapp.model.AlcoholContent(strAlcoholic = "Alcoholic")
+            )
+        )
+        val categoryResponse = FilterResponse(
+            drinks = listOf(
+                com.example.cocktailsdbapp.model.DrinkCategory(strCategory = "Cocktail")
+            )
+        )
+
+        coEvery { mockRepo.getAlcoholContent() } returns alcoholResponse
+        coEvery { mockRepo.getCategories() } returns categoryResponse
+
+        // When - First call
+        viewModel.fetchData(Constants.FILTER_ALCOHOL)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - First call
+        assertEquals("Alcoholic", viewModel.filterData.value?.first())
+
+        // When - Second call
+        viewModel.fetchData(Constants.FILTER_CATEGORY)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Second call
+        assertEquals("Cocktail", viewModel.filterData.value?.first())
+    }
+
+
+
+
+
+    @Test
+    fun `getAlcoholContent with large dataset`() = runTest {
+        // Given
+        val largeResponse = AlcoholContentResponse(
+            drinks = (1..100).map { 
+                com.example.cocktailsdbapp.model.AlcoholContent(strAlcoholic = "Alcoholic $it")
+            }
+        )
+
+        coEvery { mockRepo.getAlcoholContent() } returns largeResponse
+
+        // When
+        viewModel.fetchData(Constants.FILTER_ALCOHOL)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getAlcoholContent() }
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        assertEquals(100, result?.size)
+        assertTrue(result?.contains("Alcoholic 1") == true)
+        assertTrue(result?.contains("Alcoholic 50") == true)
+        assertTrue(result?.contains("Alcoholic 100") == true)
+    }
+
+    @Test
+    fun `getFirstLetters returns correct alphabet range`() = runTest {
+        // When
+        viewModel.fetchData(Constants.FILTER_LETTER)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        val result = viewModel.filterData.value
+        assertNotNull(result)
+        
+        // Check that all letters from A to Z are present
+        for (char in 'A'..'Z') {
+            assertTrue("Letter $char should be present", result?.contains(char.toString()) == true)
+        }
+        
+        // Check that no other characters are present
+        assertEquals(26, result?.size)
+        assertTrue(result?.all { it.length == 1 && it[0] in 'A'..'Z' } == true)
+    }
+}
diff --git a/app/src/test/java/com/example/cocktailsdbapp/ui/cocktails/CocktailsViewModelTest.kt b/app/src/test/java/com/example/cocktailsdbapp/ui/cocktails/CocktailsViewModelTest.kt
new file mode 100644
index 0000000..26bc6cf
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/ui/cocktails/CocktailsViewModelTest.kt
@@ -0,0 +1,389 @@
+package com.example.cocktailsdbapp.ui.cocktails
+
+import androidx.arch.core.executor.testing.InstantTaskExecutorRule
+import com.example.cocktailsdbapp.database.RoomCocktail
+import com.example.cocktailsdbapp.model.Cocktail
+import com.example.cocktailsdbapp.model.CocktailResponse
+import com.example.cocktailsdbapp.repository.CocktailsRepo
+import com.example.cocktailsdbapp.utils.Constants
+import io.mockk.*
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.*
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for CocktailsViewModel
+ */
+@OptIn(ExperimentalCoroutinesApi::class)
+class CocktailsViewModelTest {
+
+    @get:Rule
+    val instantTaskExecutorRule = InstantTaskExecutorRule()
+
+    private lateinit var viewModel: CocktailsViewModel
+    private lateinit var mockRepo: CocktailsRepo
+    private val testDispatcher = StandardTestDispatcher()
+
+    @Before
+    fun setup() {
+        Dispatchers.setMain(testDispatcher)
+        mockRepo = mockk()
+        viewModel = CocktailsViewModel(mockRepo)
+    }
+
+    @After
+    fun tearDown() {
+        Dispatchers.resetMain()
+        clearAllMocks()
+    }
+
+    @Test
+    fun `fetchData with alcohol filter calls correct repository method`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = Constants.FILTER_ALCOHOL
+        val filter = "Alcoholic"
+        val cocktails = listOf(
+            Cocktail("Mojito", "mojito.jpg", "11007", false),
+            Cocktail("Margarita", "margarita.jpg", "11008", false)
+        )
+        val response = CocktailResponse(drinks = cocktails)
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getCocktailsByAlcoholContent(filter) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailsByAlcoholContent(filter) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `fetchData with category filter calls correct repository method`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = Constants.FILTER_CATEGORY
+        val filter = "Cocktail"
+        val cocktails = listOf(Cocktail("Martini", "martini.jpg", "11009", false))
+        val response = CocktailResponse(drinks = cocktails)
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getCocktailsByCategory(filter) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailsByCategory(filter) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `fetchData with glass filter calls correct repository method`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = Constants.FILTER_GLASS
+        val filter = "Highball glass"
+        val cocktails = listOf(Cocktail("Mojito", "mojito.jpg", "11007", false))
+        val response = CocktailResponse(drinks = cocktails)
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getCocktailsByGlass(filter) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailsByGlass(filter) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `fetchData with ingredient filter calls correct repository method`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = Constants.FILTER_INGREDIENT
+        val filter = "Vodka"
+        val cocktails = listOf(Cocktail("Vodka Martini", "vodka_martini.jpg", "11010", false))
+        val response = CocktailResponse(drinks = cocktails)
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getCocktailsByIngredient(filter) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailsByIngredient(filter) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `fetchData with letter filter calls correct repository method`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = Constants.FILTER_LETTER
+        val filter = "M"
+        val cocktails = listOf(
+            Cocktail("Mojito", "mojito.jpg", "11007", false),
+            Cocktail("Margarita", "margarita.jpg", "11008", false),
+            Cocktail("Martini", "martini.jpg", "11009", false)
+        )
+        val response = CocktailResponse(drinks = cocktails)
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getCocktailsByFirstLetter(filter) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailsByFirstLetter(filter) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `fetchData with unknown filter returns empty response`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = "Unknown"
+        val filter = "test"
+
+        coEvery { mockRepo.getFavorites(userEmail) } returns listOf<RoomCocktail>()
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify(exactly = 0) { mockRepo.getCocktailsByAlcoholContent(any()) }
+        coVerify(exactly = 0) { mockRepo.getCocktailsByCategory(any()) }
+        coVerify(exactly = 0) { mockRepo.getCocktailsByGlass(any()) }
+        coVerify(exactly = 0) { mockRepo.getCocktailsByIngredient(any()) }
+        coVerify(exactly = 0) { mockRepo.getCocktailsByFirstLetter(any()) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `fetchData with empty response sets cocktailsData to null`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = Constants.FILTER_ALCOHOL
+        val filter = "Alcoholic"
+        val response = CocktailResponse(drinks = emptyList())
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getCocktailsByAlcoholContent(filter) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailsByAlcoholContent(filter) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `fetchData with null drinks sets cocktailsData to null`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = Constants.FILTER_ALCOHOL
+        val filter = "Alcoholic"
+        val response = CocktailResponse(drinks = null)
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getCocktailsByAlcoholContent(filter) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailsByAlcoholContent(filter) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `fetchData with null favorites still processes response`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = Constants.FILTER_ALCOHOL
+        val filter = "Alcoholic"
+        val cocktails = listOf(Cocktail("Mojito", "mojito.jpg", "11007", false))
+        val response = CocktailResponse(drinks = cocktails)
+
+        coEvery { mockRepo.getCocktailsByAlcoholContent(filter) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns null
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailsByAlcoholContent(filter) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `fetchData handles exception gracefully`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val filterCategory = Constants.FILTER_ALCOHOL
+        val filter = "Alcoholic"
+
+        coEvery { mockRepo.getCocktailsByAlcoholContent(filter) } throws Exception("Network error")
+
+        // When
+        viewModel.fetchData(userEmail, filterCategory, filter)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Should not crash
+        coVerify { mockRepo.getCocktailsByAlcoholContent(filter) }
+    }
+
+    @Test
+    fun `favoriteCocktail adds cocktail when not already favorite`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(userEmail, any()) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) }
+        coVerify {
+            mockRepo.insertCocktail(
+                userEmail,
+                match {
+                    it.strDrink == "Mojito" &&
+                    it.strDrinkThumb == "mojito.jpg" &&
+                    it.idDrink == "11007"
+                }
+            )
+        }
+    }
+
+    @Test
+    fun `favoriteCocktail removes cocktail when already favorite`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", true)
+        val existingFavorite = RoomCocktail("Mojito", "mojito.jpg", "11007")
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns existingFavorite
+        coEvery { mockRepo.removeFavorite(userEmail, cocktail.idDrink) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) }
+        coVerify { mockRepo.removeFavorite(userEmail, cocktail.idDrink) }
+        coVerify(exactly = 0) { mockRepo.insertCocktail(any(), any()) }
+    }
+
+    @Test
+    fun `favoriteCocktail toggles favorite status correctly`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Margarita", "margarita.jpg", "11008", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(userEmail, any()) } just Runs
+
+        // When - Add to favorites
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.insertCocktail(userEmail, any()) }
+    }
+
+    @Test
+    fun `favoriteCocktail with different users maintains separate favorites`() = runTest {
+        // Given
+        val user1 = "user1@example.com"
+        val user2 = "user2@example.com"
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(user1, cocktail.idDrink) } returns null
+        coEvery { mockRepo.findFavoriteCocktail(user2, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(any(), any()) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(user1, cocktail)
+        viewModel.favoriteCocktail(user2, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Both users should be able to favorite
+        coVerify { mockRepo.insertCocktail(user1, any()) }
+        coVerify { mockRepo.insertCocktail(user2, any()) }
+    }
+
+    @Test
+    fun `cocktailsData is initialized`() {
+        // Then
+        assertNotNull(viewModel.cocktailsData)
+    }
+
+    @Test
+    fun `fetchData with multiple filter types calls correct methods`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getCocktailsByAlcoholContent(any()) } returns CocktailResponse(drinks = emptyList())
+        coEvery { mockRepo.getCocktailsByCategory(any()) } returns CocktailResponse(drinks = emptyList())
+        coEvery { mockRepo.getCocktailsByGlass(any()) } returns CocktailResponse(drinks = emptyList())
+        coEvery { mockRepo.getCocktailsByIngredient(any()) } returns CocktailResponse(drinks = emptyList())
+        coEvery { mockRepo.getCocktailsByFirstLetter(any()) } returns CocktailResponse(drinks = emptyList())
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When - Test all filter types
+        viewModel.fetchData(userEmail, Constants.FILTER_ALCOHOL, "Alcoholic")
+        viewModel.fetchData(userEmail, Constants.FILTER_CATEGORY, "Cocktail")
+        viewModel.fetchData(userEmail, Constants.FILTER_GLASS, "Highball")
+        viewModel.fetchData(userEmail, Constants.FILTER_INGREDIENT, "Vodka")
+        viewModel.fetchData(userEmail, Constants.FILTER_LETTER, "M")
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - All methods should be called
+        coVerify { mockRepo.getCocktailsByAlcoholContent("Alcoholic") }
+        coVerify { mockRepo.getCocktailsByCategory("Cocktail") }
+        coVerify { mockRepo.getCocktailsByGlass("Highball") }
+        coVerify { mockRepo.getCocktailsByIngredient("Vodka") }
+        coVerify { mockRepo.getCocktailsByFirstLetter("M") }
+        coVerify(atLeast = 5) { mockRepo.getFavorites(userEmail) }
+    }
+}
+
diff --git a/app/src/test/java/com/example/cocktailsdbapp/ui/cocktails/FavoritesViewModelTest.kt b/app/src/test/java/com/example/cocktailsdbapp/ui/cocktails/FavoritesViewModelTest.kt
new file mode 100644
index 0000000..df02244
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/ui/cocktails/FavoritesViewModelTest.kt
@@ -0,0 +1,352 @@
+package com.example.cocktailsdbapp.ui.cocktails
+
+import androidx.arch.core.executor.testing.InstantTaskExecutorRule
+import com.example.cocktailsdbapp.database.RoomCocktail
+import com.example.cocktailsdbapp.model.Cocktail
+import com.example.cocktailsdbapp.repository.CocktailsRepo
+import io.mockk.*
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.*
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for FavoritesViewModel
+ */
+@OptIn(ExperimentalCoroutinesApi::class)
+class FavoritesViewModelTest {
+
+    @get:Rule
+    val instantTaskExecutorRule = InstantTaskExecutorRule()
+
+    private lateinit var viewModel: FavoritesViewModel
+    private lateinit var mockRepo: CocktailsRepo
+    private val testDispatcher = StandardTestDispatcher()
+
+    @Before
+    fun setup() {
+        Dispatchers.setMain(testDispatcher)
+        mockRepo = mockk()
+        viewModel = FavoritesViewModel(mockRepo)
+    }
+
+    @After
+    fun tearDown() {
+        Dispatchers.resetMain()
+        clearAllMocks()
+    }
+
+    @Test
+    fun `getFavorites with valid favorites returns converted cocktails`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val roomFavorites = listOf(
+            RoomCocktail("Mojito", "mojito.jpg", "11007"),
+            RoomCocktail("Margarita", "margarita.jpg", "11008"),
+            RoomCocktail("Martini", "martini.jpg", "11009")
+        )
+
+        coEvery { mockRepo.getFavorites(userEmail) } returns roomFavorites
+
+        // When
+        viewModel.getFavorites(userEmail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getFavorites(userEmail) }
+        assertNotNull(viewModel.favoritesData.value)
+        assertEquals(3, viewModel.favoritesData.value?.size)
+        
+        // Verify all cocktails are marked as favorites
+        viewModel.favoritesData.value?.forEach { cocktail ->
+            assertTrue(cocktail.isFavorite)
+        }
+    }
+
+    @Test
+    fun `getFavorites with empty favorites returns empty list`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val emptyFavorites = emptyList<RoomCocktail>()
+
+        coEvery { mockRepo.getFavorites(userEmail) } returns emptyFavorites
+
+        // When
+        viewModel.getFavorites(userEmail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getFavorites(userEmail) }
+        assertNotNull(viewModel.favoritesData.value)
+        assertTrue(viewModel.favoritesData.value!!.isEmpty())
+    }
+
+    @Test
+    fun `getFavorites with null favorites returns null`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+
+        coEvery { mockRepo.getFavorites(userEmail) } returns null
+
+        // When
+        viewModel.getFavorites(userEmail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getFavorites(userEmail) }
+        assertNull(viewModel.favoritesData.value)
+    }
+
+    @Test
+    fun `getFavorites with single favorite returns single cocktail`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val singleFavorite = listOf(RoomCocktail("Mojito", "mojito.jpg", "11007"))
+
+        coEvery { mockRepo.getFavorites(userEmail) } returns singleFavorite
+
+        // When
+        viewModel.getFavorites(userEmail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getFavorites(userEmail) }
+        assertNotNull(viewModel.favoritesData.value)
+        assertEquals(1, viewModel.favoritesData.value?.size)
+        assertEquals("Mojito", viewModel.favoritesData.value?.first()?.strDrink)
+        assertTrue(viewModel.favoritesData.value?.first()?.isFavorite == true)
+    }
+
+    @Test
+    fun `getFavorites handles exception gracefully`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+
+        coEvery { mockRepo.getFavorites(userEmail) } throws Exception("Database error")
+
+        // When
+        viewModel.getFavorites(userEmail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Should not crash
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `favoriteCocktail adds cocktail when not already favorite`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(userEmail, any()) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) }
+        coVerify {
+            mockRepo.insertCocktail(
+                userEmail,
+                match {
+                    it.strDrink == "Mojito" &&
+                    it.strDrinkThumb == "mojito.jpg" &&
+                    it.idDrink == "11007"
+                }
+            )
+        }
+    }
+
+    @Test
+    fun `favoriteCocktail removes cocktail when already favorite`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", true)
+        val existingFavorite = RoomCocktail("Mojito", "mojito.jpg", "11007")
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns existingFavorite
+        coEvery { mockRepo.removeFavorite(userEmail, cocktail.idDrink) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) }
+        coVerify { mockRepo.removeFavorite(userEmail, cocktail.idDrink) }
+        coVerify(exactly = 0) { mockRepo.insertCocktail(any(), any()) }
+    }
+
+    @Test
+    fun `favoriteCocktail toggles favorite status correctly`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Margarita", "margarita.jpg", "11008", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(userEmail, any()) } just Runs
+
+        // When - Add to favorites
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.insertCocktail(userEmail, any()) }
+    }
+
+    @Test
+    fun `favoriteCocktail with different users maintains separate favorites`() = runTest {
+        // Given
+        val user1 = "user1@example.com"
+        val user2 = "user2@example.com"
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(user1, cocktail.idDrink) } returns null
+        coEvery { mockRepo.findFavoriteCocktail(user2, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(any(), any()) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(user1, cocktail)
+        viewModel.favoriteCocktail(user2, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Both users should be able to favorite
+        coVerify { mockRepo.insertCocktail(user1, any()) }
+        coVerify { mockRepo.insertCocktail(user2, any()) }
+    }
+
+    @Test
+    fun `favoriteCocktail creates correct RoomCocktail`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Pia Colada", "pina.jpg", "12345", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(userEmail, any()) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify {
+            mockRepo.insertCocktail(
+                userEmail,
+                match {
+                    it.strDrink == "Pia Colada" &&
+                    it.strDrinkThumb == "pina.jpg" &&
+                    it.idDrink == "12345"
+                }
+            )
+        }
+    }
+
+    @Test
+    fun `favoritesData is initialized`() {
+        // Then
+        assertNotNull(viewModel.favoritesData)
+    }
+
+    @Test
+    fun `getFavorites with multiple calls processes each correctly`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val firstCallFavorites = listOf(RoomCocktail("Mojito", "mojito.jpg", "11007"))
+        val secondCallFavorites = listOf(
+            RoomCocktail("Mojito", "mojito.jpg", "11007"),
+            RoomCocktail("Margarita", "margarita.jpg", "11008")
+        )
+
+        coEvery { mockRepo.getFavorites(userEmail) } returnsMany listOf(firstCallFavorites, secondCallFavorites)
+
+        // When - First call
+        viewModel.getFavorites(userEmail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - First call
+        assertEquals(1, viewModel.favoritesData.value?.size)
+        assertEquals("Mojito", viewModel.favoritesData.value?.first()?.strDrink)
+
+        // When - Second call
+        viewModel.getFavorites(userEmail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Second call
+        assertEquals(2, viewModel.favoritesData.value?.size)
+        assertEquals("Margarita", viewModel.favoritesData.value?.last()?.strDrink)
+    }
+
+    @Test
+    fun `getFavorites converts RoomCocktail to Cocktail with correct properties`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val roomFavorites = listOf(
+            RoomCocktail("Test Cocktail", "test.jpg", "99999")
+        )
+
+        coEvery { mockRepo.getFavorites(userEmail) } returns roomFavorites
+
+        // When
+        viewModel.getFavorites(userEmail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        val convertedCocktail = viewModel.favoritesData.value?.first()
+        assertNotNull(convertedCocktail)
+        assertEquals("Test Cocktail", convertedCocktail?.strDrink)
+        assertEquals("test.jpg", convertedCocktail?.strDrinkThumb)
+        assertEquals("99999", convertedCocktail?.idDrink)
+        assertTrue(convertedCocktail?.isFavorite == true)
+    }
+
+    @Test
+    fun `favoriteCocktail handles null existing favorite correctly`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("New Cocktail", "new.jpg", "11111", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(userEmail, any()) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.insertCocktail(userEmail, any()) }
+        coVerify(exactly = 0) { mockRepo.removeFavorite(any(), any()) }
+    }
+
+    @Test
+    fun `favoriteCocktail handles existing favorite correctly`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Existing Cocktail", "existing.jpg", "22222", true)
+        val existingFavorite = RoomCocktail("Existing Cocktail", "existing.jpg", "22222")
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns existingFavorite
+        coEvery { mockRepo.removeFavorite(userEmail, cocktail.idDrink) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.removeFavorite(userEmail, cocktail.idDrink) }
+        coVerify(exactly = 0) { mockRepo.insertCocktail(any(), any()) }
+    }
+}
+
diff --git a/app/src/test/java/com/example/cocktailsdbapp/ui/details/CocktailDetailsViewModelTest.kt b/app/src/test/java/com/example/cocktailsdbapp/ui/details/CocktailDetailsViewModelTest.kt
new file mode 100644
index 0000000..7307add
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/ui/details/CocktailDetailsViewModelTest.kt
@@ -0,0 +1,673 @@
+package com.example.cocktailsdbapp.ui.details
+
+import androidx.arch.core.executor.testing.InstantTaskExecutorRule
+import com.example.cocktailsdbapp.model.CocktailDetails
+import com.example.cocktailsdbapp.model.CocktailDetailsResponse
+import com.example.cocktailsdbapp.repository.CocktailsRepo
+import io.mockk.*
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.*
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for CocktailDetailsViewModel
+ */
+@OptIn(ExperimentalCoroutinesApi::class)
+class CocktailDetailsViewModelTest {
+
+    @get:Rule
+    val instantTaskExecutorRule = InstantTaskExecutorRule()
+
+    private lateinit var viewModel: CocktailDetailsViewModel
+    private lateinit var mockRepo: CocktailsRepo
+    private val testDispatcher = StandardTestDispatcher()
+
+    @Before
+    fun setup() {
+        mockRepo = mockk()
+        viewModel = CocktailDetailsViewModel(mockRepo)
+        Dispatchers.setMain(testDispatcher)
+    }
+
+    @After
+    fun tearDown() {
+        clearAllMocks()
+        Dispatchers.resetMain()
+    }
+
+    @Test
+    fun `getDetails with valid cocktail details returns first cocktail`() = runTest {
+        // Given
+        val cocktailId = "11007"
+        val cocktailDetails = CocktailDetails(
+            idDrink = "11007",
+            strDrink = "Mojito",
+            strDrinkAlternate = null,
+            strTags = "IBA,ContemporaryClassic",
+            strVideo = null,
+            strCategory = "Cocktail",
+            strIBA = "Contemporary Classics",
+            strAlcoholic = "Alcoholic",
+            strGlass = "Highball glass",
+            strInstructions = "Muddle mint leaves with sugar and lime juice. Add a splash of soda water and fill the glass with cracked ice. Pour the rum and top with soda water. Garnish and serve with straw.",
+            strInstructionsES = null,
+            strInstructionsDE = null,
+            strInstructionsFR = null,
+            strInstructionsIT = null,
+            strInstructionsZH_HANS = null,
+            strInstructionsZH_HANT = null,
+            strDrinkThumb = "https://www.thecocktaildb.com/images/media/drink/metwgh1606770327.jpg",
+            strIngredient1 = "White rum",
+            strIngredient2 = "Lime",
+            strIngredient3 = "Sugar",
+            strIngredient4 = "Mint",
+            strIngredient5 = "Soda water",
+            strIngredient6 = null,
+            strIngredient7 = null,
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = "2-3 oz",
+            strMeasure2 = "Juice of 1/2",
+            strMeasure3 = "2 tsp",
+            strMeasure4 = "2-4",
+            strMeasure5 = "Top",
+            strMeasure6 = null,
+            strMeasure7 = null,
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = null,
+            strImageAttribution = null,
+            strCreativeCommonsConfirmed = null,
+            dateModified = null,
+            isFavorite = false
+        )
+        val response = CocktailDetailsResponse(drinks = listOf(cocktailDetails))
+
+        coEvery { mockRepo.getCocktailDetails(cocktailId) } returns response
+
+        // When
+        viewModel.getDetails(cocktailId)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailDetails(cocktailId) }
+        assertNotNull(viewModel.cocktailDetailsData.value)
+        assertEquals("11007", viewModel.cocktailDetailsData.value?.idDrink)
+        assertEquals("Mojito", viewModel.cocktailDetailsData.value?.strDrink)
+        assertEquals("Cocktail", viewModel.cocktailDetailsData.value?.strCategory)
+    }
+
+    @Test
+    fun `getDetails with multiple cocktails returns first one`() = runTest {
+        // Given
+        val cocktailId = "11007"
+        val firstCocktail = CocktailDetails(
+            idDrink = "11007",
+            strDrink = "Mojito",
+            strDrinkAlternate = null,
+            strTags = null,
+            strVideo = null,
+            strCategory = "Cocktail",
+            strIBA = null,
+            strAlcoholic = "Alcoholic",
+            strGlass = "Highball glass",
+            strInstructions = "Mix ingredients",
+            strInstructionsES = null,
+            strInstructionsDE = null,
+            strInstructionsFR = null,
+            strInstructionsIT = null,
+            strInstructionsZH_HANS = null,
+            strInstructionsZH_HANT = null,
+            strDrinkThumb = "mojito.jpg",
+            strIngredient1 = "Rum",
+            strIngredient2 = "Lime",
+            strIngredient3 = null,
+            strIngredient4 = null,
+            strIngredient5 = null,
+            strIngredient6 = null,
+            strIngredient7 = null,
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = "2 oz",
+            strMeasure2 = "1 oz",
+            strMeasure3 = null,
+            strMeasure4 = null,
+            strMeasure5 = null,
+            strMeasure6 = null,
+            strMeasure7 = null,
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = null,
+            strImageAttribution = null,
+            strCreativeCommonsConfirmed = null,
+            dateModified = null,
+            isFavorite = false
+        )
+        val secondCocktail = CocktailDetails(
+            idDrink = "11008",
+            strDrink = "Margarita",
+            strDrinkAlternate = null,
+            strTags = null,
+            strVideo = null,
+            strCategory = "Cocktail",
+            strIBA = null,
+            strAlcoholic = "Alcoholic",
+            strGlass = "Cocktail glass",
+            strInstructions = "Mix ingredients",
+            strInstructionsES = null,
+            strInstructionsDE = null,
+            strInstructionsFR = null,
+            strInstructionsIT = null,
+            strInstructionsZH_HANS = null,
+            strInstructionsZH_HANT = null,
+            strDrinkThumb = "margarita.jpg",
+            strIngredient1 = "Tequila",
+            strIngredient2 = "Lime",
+            strIngredient3 = null,
+            strIngredient4 = null,
+            strIngredient5 = null,
+            strIngredient6 = null,
+            strIngredient7 = null,
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = "2 oz",
+            strMeasure2 = "1 oz",
+            strMeasure3 = null,
+            strMeasure4 = null,
+            strMeasure5 = null,
+            strMeasure6 = null,
+            strMeasure7 = null,
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = null,
+            strImageAttribution = null,
+            strCreativeCommonsConfirmed = null,
+            dateModified = null,
+            isFavorite = false
+        )
+        val response = CocktailDetailsResponse(drinks = listOf(firstCocktail, secondCocktail))
+
+        coEvery { mockRepo.getCocktailDetails(cocktailId) } returns response
+
+        // When
+        viewModel.getDetails(cocktailId)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailDetails(cocktailId) }
+        assertNotNull(viewModel.cocktailDetailsData.value)
+        assertEquals("11007", viewModel.cocktailDetailsData.value?.idDrink)
+        assertEquals("Mojito", viewModel.cocktailDetailsData.value?.strDrink)
+        // Should return the first cocktail, not the second
+        assertNotEquals("11008", viewModel.cocktailDetailsData.value?.idDrink)
+    }
+
+    @Test
+    fun `getDetails with empty drinks list sets null`() = runTest {
+        // Given
+        val cocktailId = "11007"
+        val response = CocktailDetailsResponse(drinks = emptyList())
+
+        coEvery { mockRepo.getCocktailDetails(cocktailId) } returns response
+
+        // When
+        viewModel.getDetails(cocktailId)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailDetails(cocktailId) }
+        assertNull(viewModel.cocktailDetailsData.value)
+    }
+
+    @Test
+    fun `getDetails with null drinks sets null`() = runTest {
+        // Given
+        val cocktailId = "11007"
+        val response = CocktailDetailsResponse(drinks = null)
+
+        coEvery { mockRepo.getCocktailDetails(cocktailId) } returns response
+
+        // When
+        viewModel.getDetails(cocktailId)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailDetails(cocktailId) }
+        assertNull(viewModel.cocktailDetailsData.value)
+    }
+
+    @Test
+    fun `getDetails handles exception gracefully`() = runTest {
+        // Given
+        val cocktailId = "11007"
+
+        coEvery { mockRepo.getCocktailDetails(cocktailId) } throws Exception("Network error")
+
+        // When
+        viewModel.getDetails(cocktailId)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Should not crash
+        coVerify { mockRepo.getCocktailDetails(cocktailId) }
+    }
+
+    @Test
+    fun `getDetails with different cocktail IDs calls repository with correct ID`() = runTest {
+        // Given
+        val cocktailId1 = "11007"
+        val cocktailId2 = "11008"
+        val cocktailDetails1 = CocktailDetails(
+            idDrink = "11007",
+            strDrink = "Mojito",
+            strDrinkAlternate = null,
+            strTags = null,
+            strVideo = null,
+            strCategory = "Cocktail",
+            strIBA = null,
+            strAlcoholic = "Alcoholic",
+            strGlass = "Highball glass",
+            strInstructions = "Mix ingredients",
+            strInstructionsES = null,
+            strInstructionsDE = null,
+            strInstructionsFR = null,
+            strInstructionsIT = null,
+            strInstructionsZH_HANS = null,
+            strInstructionsZH_HANT = null,
+            strDrinkThumb = "mojito.jpg",
+            strIngredient1 = "Rum",
+            strIngredient2 = "Lime",
+            strIngredient3 = null,
+            strIngredient4 = null,
+            strIngredient5 = null,
+            strIngredient6 = null,
+            strIngredient7 = null,
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = "2 oz",
+            strMeasure2 = "1 oz",
+            strMeasure3 = null,
+            strMeasure4 = null,
+            strMeasure5 = null,
+            strMeasure6 = null,
+            strMeasure7 = null,
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = null,
+            strImageAttribution = null,
+            strCreativeCommonsConfirmed = null,
+            dateModified = null,
+            isFavorite = false
+        )
+        val cocktailDetails2 = CocktailDetails(
+            idDrink = "11008",
+            strDrink = "Margarita",
+            strDrinkAlternate = null,
+            strTags = null,
+            strVideo = null,
+            strCategory = "Cocktail",
+            strIBA = null,
+            strAlcoholic = "Alcoholic",
+            strGlass = "Cocktail glass",
+            strInstructions = "Mix ingredients",
+            strInstructionsES = null,
+            strInstructionsDE = null,
+            strInstructionsFR = null,
+            strInstructionsIT = null,
+            strInstructionsZH_HANS = null,
+            strInstructionsZH_HANT = null,
+            strDrinkThumb = "margarita.jpg",
+            strIngredient1 = "Tequila",
+            strIngredient2 = "Lime",
+            strIngredient3 = null,
+            strIngredient4 = null,
+            strIngredient5 = null,
+            strIngredient6 = null,
+            strIngredient7 = null,
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = "2 oz",
+            strMeasure2 = "1 oz",
+            strMeasure3 = null,
+            strMeasure4 = null,
+            strMeasure5 = null,
+            strMeasure6 = null,
+            strMeasure7 = null,
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = null,
+            strImageAttribution = null,
+            strCreativeCommonsConfirmed = null,
+            dateModified = null,
+            isFavorite = false
+        )
+
+        coEvery { mockRepo.getCocktailDetails(cocktailId1) } returns CocktailDetailsResponse(drinks = listOf(cocktailDetails1))
+        coEvery { mockRepo.getCocktailDetails(cocktailId2) } returns CocktailDetailsResponse(drinks = listOf(cocktailDetails2))
+
+        // When
+        viewModel.getDetails(cocktailId1)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        viewModel.getDetails(cocktailId2)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailDetails(cocktailId1) }
+        coVerify { mockRepo.getCocktailDetails(cocktailId2) }
+        assertEquals("11008", viewModel.cocktailDetailsData.value?.idDrink)
+        assertEquals("Margarita", viewModel.cocktailDetailsData.value?.strDrink)
+    }
+
+    @Test
+    fun `cocktailDetailsData is initialized`() {
+        // Then
+        assertNotNull(viewModel.cocktailDetailsData)
+    }
+
+    @Test
+    fun `getDetails with cocktail having all fields populated`() = runTest {
+        // Given
+        val cocktailId = "11007"
+        val cocktailDetails = CocktailDetails(
+            idDrink = "11007",
+            strDrink = "Mojito",
+            strDrinkAlternate = "Cuban Mojito",
+            strTags = "IBA,ContemporaryClassic,Summer",
+            strVideo = "https://www.youtube.com/watch?v=example",
+            strCategory = "Cocktail",
+            strIBA = "Contemporary Classics",
+            strAlcoholic = "Alcoholic",
+            strGlass = "Highball glass",
+            strInstructions = "Muddle mint leaves with sugar and lime juice. Add a splash of soda water and fill the glass with cracked ice. Pour the rum and top with soda water. Garnish and serve with straw.",
+            strInstructionsES = "Machacar las hojas de menta con azcar y jugo de lima. Agregar un chorrito de agua con gas y llenar el vaso con hielo picado. Verter el ron y completar con agua con gas. Decorar y servir con pajita.",
+            strInstructionsDE = "Minzbltter mit Zucker und Limettensaft zerdrcken. Einen Spritzer Sodawasser hinzufgen und das Glas mit gebrochenem Eis fllen. Den Rum eingieen und mit Sodawasser auffllen. Garnieren und mit Strohhalm servieren.",
+            strInstructionsFR = "craser les feuilles de menthe avec le sucre et le jus de citron vert. Ajouter un claboussure d'eau gazeuse et remplir le verre avec de la glace pile. Verser le rhum et complter avec de l'eau gazeuse. Garnir et servir avec une paille.",
+            strInstructionsIT = "Schiacciare le foglie di menta con zucchero e succo di lime. Aggiungere uno spruzzo di acqua gassata e riempire il bicchiere con ghiaccio tritato. Versare il rum e completare con acqua gassata. Guarnire e servire con cannuccia.",
+            strInstructionsZH_HANS = "",
+            strInstructionsZH_HANT = "",
+            strDrinkThumb = "https://www.thecocktaildb.com/images/media/drink/metwgh1606770327.jpg",
+            strIngredient1 = "White rum",
+            strIngredient2 = "Lime",
+            strIngredient3 = "Sugar",
+            strIngredient4 = "Mint",
+            strIngredient5 = "Soda water",
+            strIngredient6 = "Ice",
+            strIngredient7 = "Mint sprig",
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = "2-3 oz",
+            strMeasure2 = "Juice of 1/2",
+            strMeasure3 = "2 tsp",
+            strMeasure4 = "2-4",
+            strMeasure5 = "Top",
+            strMeasure6 = "Fill",
+            strMeasure7 = "Garnish",
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = "https://commons.wikimedia.org/wiki/File:Mojito_001.jpg",
+            strImageAttribution = "TheCocktailDB.com",
+            strCreativeCommonsConfirmed = "Yes",
+            dateModified = "2017-09-07 21:42:09",
+            isFavorite = false
+        )
+        val response = CocktailDetailsResponse(drinks = listOf(cocktailDetails))
+
+        coEvery { mockRepo.getCocktailDetails(cocktailId) } returns response
+
+        // When
+        viewModel.getDetails(cocktailId)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getCocktailDetails(cocktailId) }
+        val result = viewModel.cocktailDetailsData.value
+        assertNotNull(result)
+        assertEquals("11007", result?.idDrink)
+        assertEquals("Mojito", result?.strDrink)
+        assertEquals("Cuban Mojito", result?.strDrinkAlternate)
+        assertEquals("IBA,ContemporaryClassic,Summer", result?.strTags)
+        assertEquals("https://www.youtube.com/watch?v=example", result?.strVideo)
+        assertEquals("Cocktail", result?.strCategory)
+        assertEquals("Contemporary Classics", result?.strIBA)
+        assertEquals("Alcoholic", result?.strAlcoholic)
+        assertEquals("Highball glass", result?.strGlass)
+        assertTrue(result?.strInstructions?.contains("Muddle mint leaves") == true)
+        assertTrue(result?.strInstructionsES?.contains("Machacar las hojas") == true)
+        assertTrue(result?.strInstructionsDE?.contains("Minzbltter mit Zucker") == true)
+        assertTrue(result?.strInstructionsFR?.contains("craser les feuilles") == true)
+        assertTrue(result?.strInstructionsIT?.contains("Schiacciare le foglie") == true)
+        assertTrue(result?.strInstructionsZH_HANS?.contains("") == true)
+        assertTrue(result?.strInstructionsZH_HANT?.contains("") == true)
+        assertEquals("https://www.thecocktaildb.com/images/media/drink/metwgh1606770327.jpg", result?.strDrinkThumb)
+        assertEquals("White rum", result?.strIngredient1)
+        assertEquals("Lime", result?.strIngredient2)
+        assertEquals("Sugar", result?.strIngredient3)
+        assertEquals("Mint", result?.strIngredient4)
+        assertEquals("Soda water", result?.strIngredient5)
+        assertEquals("Ice", result?.strIngredient6)
+        assertEquals("Mint sprig", result?.strIngredient7)
+        assertEquals("2-3 oz", result?.strMeasure1)
+        assertEquals("Juice of 1/2", result?.strMeasure2)
+        assertEquals("2 tsp", result?.strMeasure3)
+        assertEquals("2-4", result?.strMeasure4)
+        assertEquals("Top", result?.strMeasure5)
+        assertEquals("Fill", result?.strMeasure6)
+        assertEquals("Garnish", result?.strMeasure7)
+        assertEquals("https://commons.wikimedia.org/wiki/File:Mojito_001.jpg", result?.strImageSource)
+        assertEquals("TheCocktailDB.com", result?.strImageAttribution)
+        assertEquals("Yes", result?.strCreativeCommonsConfirmed)
+        assertEquals("2017-09-07 21:42:09", result?.dateModified)
+        assertFalse(result?.isFavorite == true)
+    }
+
+    @Test
+    fun `getDetails with multiple calls updates data correctly`() = runTest {
+        // Given
+        val cocktailId1 = "11007"
+        val cocktailId2 = "11008"
+        val cocktailDetails1 = CocktailDetails(
+            idDrink = "11007",
+            strDrink = "Mojito",
+            strDrinkAlternate = null,
+            strTags = null,
+            strVideo = null,
+            strCategory = "Cocktail",
+            strIBA = null,
+            strAlcoholic = "Alcoholic",
+            strGlass = "Highball glass",
+            strInstructions = "Mix ingredients",
+            strInstructionsES = null,
+            strInstructionsDE = null,
+            strInstructionsFR = null,
+            strInstructionsIT = null,
+            strInstructionsZH_HANS = null,
+            strInstructionsZH_HANT = null,
+            strDrinkThumb = "mojito.jpg",
+            strIngredient1 = "Rum",
+            strIngredient2 = "Lime",
+            strIngredient3 = null,
+            strIngredient4 = null,
+            strIngredient5 = null,
+            strIngredient6 = null,
+            strIngredient7 = null,
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = "2 oz",
+            strMeasure2 = "1 oz",
+            strMeasure3 = null,
+            strMeasure4 = null,
+            strMeasure5 = null,
+            strMeasure6 = null,
+            strMeasure7 = null,
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = null,
+            strImageAttribution = null,
+            strCreativeCommonsConfirmed = null,
+            dateModified = null,
+            isFavorite = false
+        )
+        val cocktailDetails2 = CocktailDetails(
+            idDrink = "11008",
+            strDrink = "Margarita",
+            strDrinkAlternate = null,
+            strTags = null,
+            strVideo = null,
+            strCategory = "Cocktail",
+            strIBA = null,
+            strAlcoholic = "Alcoholic",
+            strGlass = "Cocktail glass",
+            strInstructions = "Mix ingredients",
+            strInstructionsES = null,
+            strInstructionsDE = null,
+            strInstructionsFR = null,
+            strInstructionsIT = null,
+            strInstructionsZH_HANS = null,
+            strInstructionsZH_HANT = null,
+            strDrinkThumb = "margarita.jpg",
+            strIngredient1 = "Tequila",
+            strIngredient2 = "Lime",
+            strIngredient3 = null,
+            strIngredient4 = null,
+            strIngredient5 = null,
+            strIngredient6 = null,
+            strIngredient7 = null,
+            strIngredient8 = null,
+            strIngredient9 = null,
+            strIngredient10 = null,
+            strIngredient11 = null,
+            strIngredient12 = null,
+            strIngredient13 = null,
+            strIngredient14 = null,
+            strIngredient15 = null,
+            strMeasure1 = "2 oz",
+            strMeasure2 = "1 oz",
+            strMeasure3 = null,
+            strMeasure4 = null,
+            strMeasure5 = null,
+            strMeasure6 = null,
+            strMeasure7 = null,
+            strMeasure8 = null,
+            strMeasure9 = null,
+            strMeasure10 = null,
+            strMeasure11 = null,
+            strMeasure12 = null,
+            strMeasure13 = null,
+            strMeasure14 = null,
+            strMeasure15 = null,
+            strImageSource = null,
+            strImageAttribution = null,
+            strCreativeCommonsConfirmed = null,
+            dateModified = null,
+            isFavorite = false
+        )
+
+        coEvery { mockRepo.getCocktailDetails(cocktailId1) } returns CocktailDetailsResponse(drinks = listOf(cocktailDetails1))
+        coEvery { mockRepo.getCocktailDetails(cocktailId2) } returns CocktailDetailsResponse(drinks = listOf(cocktailDetails2))
+
+        // When - First call
+        viewModel.getDetails(cocktailId1)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - First call
+        assertEquals("11007", viewModel.cocktailDetailsData.value?.idDrink)
+        assertEquals("Mojito", viewModel.cocktailDetailsData.value?.strDrink)
+
+        // When - Second call
+        viewModel.getDetails(cocktailId2)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Second call
+        assertEquals("11008", viewModel.cocktailDetailsData.value?.idDrink)
+        assertEquals("Margarita", viewModel.cocktailDetailsData.value?.strDrink)
+    }
+}
diff --git a/app/src/test/java/com/example/cocktailsdbapp/ui/search/SearchViewModelTest.kt b/app/src/test/java/com/example/cocktailsdbapp/ui/search/SearchViewModelTest.kt
new file mode 100644
index 0000000..f567f67
--- /dev/null
+++ b/app/src/test/java/com/example/cocktailsdbapp/ui/search/SearchViewModelTest.kt
@@ -0,0 +1,323 @@
+package com.example.cocktailsdbapp.ui.search
+
+import androidx.arch.core.executor.testing.InstantTaskExecutorRule
+import com.example.cocktailsdbapp.database.RoomCocktail
+import com.example.cocktailsdbapp.model.Cocktail
+import com.example.cocktailsdbapp.model.CocktailResponse
+import com.example.cocktailsdbapp.repository.CocktailsRepo
+import io.mockk.*
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.*
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.Assert.*
+
+/**
+ * Unit tests for SearchViewModel
+ */
+@OptIn(ExperimentalCoroutinesApi::class)
+class SearchViewModelTest {
+
+    @get:Rule
+    val instantTaskExecutorRule = InstantTaskExecutorRule()
+
+    private lateinit var viewModel: SearchViewModel
+    private lateinit var mockRepo: CocktailsRepo
+    private val testDispatcher = StandardTestDispatcher()
+
+    @Before
+    fun setup() {
+        Dispatchers.setMain(testDispatcher)
+        mockRepo = mockk()
+        viewModel = SearchViewModel(mockRepo)
+    }
+
+    @After
+    fun tearDown() {
+        Dispatchers.resetMain()
+        clearAllMocks()
+    }
+
+    @Test
+    fun `setSearchQuery updates search query flow`() {
+        // Given
+        val query = "mojito"
+
+        // When
+        viewModel.setSearchQuery(query)
+
+        // Then - Query is set, searchResultsData is initialized
+        assertNotNull(viewModel.searchResultsData)
+    }
+
+    @Test
+    fun `executeSearch with valid results updates searchResultsData`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val query = "mojito"
+        val cocktails = listOf(
+            Cocktail("Mojito", "mojito.jpg", "11007", false),
+            Cocktail("Mint Mojito", "mint_mojito.jpg", "11008", false)
+        )
+        val response = CocktailResponse(drinks = cocktails)
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getSearch(query) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.setSearchQuery(query)
+        viewModel.fetchSearchData(userEmail)
+        advanceTimeBy(800) // Debounce time + buffer
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getSearch(query) }
+        coVerify { mockRepo.getFavorites(userEmail) }
+    }
+
+    @Test
+    fun `executeSearch with empty results sets searchResultsData to null`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val query = "nonexistent"
+        val response = CocktailResponse(drinks = emptyList())
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getSearch(query) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.setSearchQuery(query)
+        viewModel.fetchSearchData(userEmail)
+        advanceTimeBy(800)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getSearch(query) }
+    }
+
+    @Test
+    fun `executeSearch with null drinks sets searchResultsData to null`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val query = "test"
+        val response = CocktailResponse(drinks = null)
+        val favorites = listOf<RoomCocktail>()
+
+        coEvery { mockRepo.getSearch(query) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns favorites
+
+        // When
+        viewModel.setSearchQuery(query)
+        viewModel.fetchSearchData(userEmail)
+        advanceTimeBy(800)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.getSearch(query) }
+    }
+
+    @Test
+    fun `executeSearch handles exception gracefully`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val query = "error"
+
+        coEvery { mockRepo.getSearch(query) } throws Exception("Network error")
+
+        // When
+        viewModel.setSearchQuery(query)
+        viewModel.fetchSearchData(userEmail)
+        advanceTimeBy(800)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Should not crash
+        coVerify { mockRepo.getSearch(query) }
+    }
+
+    @Test
+    fun `favoriteCocktail adds cocktail when not already favorite`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", false)
+        val roomCocktail = RoomCocktail("Mojito", "mojito.jpg", "11007")
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(userEmail, any()) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) }
+        coVerify {
+            mockRepo.insertCocktail(
+                userEmail,
+                match {
+                    it.strDrink == "Mojito" &&
+                    it.strDrinkThumb == "mojito.jpg" &&
+                    it.idDrink == "11007"
+                }
+            )
+        }
+    }
+
+    @Test
+    fun `favoriteCocktail removes cocktail when already favorite`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", true)
+        val existingFavorite = RoomCocktail("Mojito", "mojito.jpg", "11007")
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns existingFavorite
+        coEvery { mockRepo.removeFavorite(userEmail, cocktail.idDrink) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) }
+        coVerify { mockRepo.removeFavorite(userEmail, cocktail.idDrink) }
+        coVerify(exactly = 0) { mockRepo.insertCocktail(any(), any()) }
+    }
+
+    @Test
+    fun `favoriteCocktail toggles favorite status correctly`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Margarita", "margarita.jpg", "11008", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(userEmail, any()) } just Runs
+
+        // When - Add to favorites
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { mockRepo.insertCocktail(userEmail, any()) }
+    }
+
+    @Test
+    fun `fetchSearchData cancels previous search job`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val query1 = "mojito"
+        val query2 = "margarita"
+        val response = CocktailResponse(drinks = emptyList())
+
+        coEvery { mockRepo.getSearch(any()) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns emptyList()
+
+        // When - Start first search
+        viewModel.setSearchQuery(query1)
+        viewModel.fetchSearchData(userEmail)
+        
+        // Immediately start second search (should cancel first)
+        viewModel.setSearchQuery(query2)
+        viewModel.fetchSearchData(userEmail)
+        
+        advanceTimeBy(800)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Second query should be executed
+        coVerify(atLeast = 1) { mockRepo.getSearch(any()) }
+    }
+
+    @Test
+    fun `debounce prevents rapid search calls`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val response = CocktailResponse(drinks = emptyList())
+
+        coEvery { mockRepo.getSearch(any()) } returns response
+        coEvery { mockRepo.getFavorites(userEmail) } returns emptyList()
+
+        // When - Rapid queries
+        viewModel.setSearchQuery("m")
+        viewModel.fetchSearchData(userEmail)
+        advanceTimeBy(100)
+        
+        viewModel.setSearchQuery("mo")
+        advanceTimeBy(100)
+        
+        viewModel.setSearchQuery("moj")
+        advanceTimeBy(100)
+        
+        viewModel.setSearchQuery("moji")
+        advanceTimeBy(100)
+        
+        viewModel.setSearchQuery("mojit")
+        advanceTimeBy(100)
+        
+        viewModel.setSearchQuery("mojito")
+        advanceTimeBy(800) // Wait for debounce
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Should only search once after debounce period
+        coVerify(atLeast = 1) { mockRepo.getSearch("mojito") }
+    }
+
+    @Test
+    fun `favoriteCocktail with different users maintains separate favorites`() = runTest {
+        // Given
+        val user1 = "user1@example.com"
+        val user2 = "user2@example.com"
+        val cocktail = Cocktail("Mojito", "mojito.jpg", "11007", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(user1, cocktail.idDrink) } returns null
+        coEvery { mockRepo.findFavoriteCocktail(user2, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(any(), any()) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(user1, cocktail)
+        viewModel.favoriteCocktail(user2, cocktail)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then - Both users should be able to favorite
+        coVerify { mockRepo.insertCocktail(user1, any()) }
+        coVerify { mockRepo.insertCocktail(user2, any()) }
+    }
+
+    @Test
+    fun `searchResultsData is initialized`() {
+        // Then
+        assertNotNull(viewModel.searchResultsData)
+    }
+
+    @Test
+    fun `favoriteCocktail calls insertCocktail with correct parameters`() = runTest {
+        // Given
+        val userEmail = "test@example.com"
+        val cocktail = Cocktail("Pia Colada", "pina.jpg", "12345", false)
+
+        coEvery { mockRepo.findFavoriteCocktail(userEmail, cocktail.idDrink) } returns null
+        coEvery { mockRepo.insertCocktail(userEmail, any()) } just Runs
+
+        // When
+        viewModel.favoriteCocktail(userEmail, cocktail)
+        
+        // Wait for the IO dispatcher coroutine to complete
+        advanceTimeBy(1000)
+        testDispatcher.scheduler.advanceUntilIdle()
+
+        // Then
+        coVerify { 
+            mockRepo.insertCocktail(
+                userEmail,
+                match { 
+                    it.strDrink == "Pia Colada" &&
+                    it.strDrinkThumb == "pina.jpg" &&
+                    it.idDrink == "12345"
+                }
+            ) 
+        }
+    }
+}
+
diff --git a/build.gradle.kts b/build.gradle.kts
index 178b098..af0376a 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -5,4 +5,5 @@ plugins {
     alias(libs.plugins.ksp) apply false
     alias(libs.plugins.google.dagger.hilt) apply false
     alias(libs.plugins.androidx.navigation.safeargs) apply false
+    id("org.jetbrains.kotlinx.kover") version "0.8.3"
 }
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 87e06c0..8f2b5cc 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -17,6 +17,8 @@ navigation-fragment-ktx = "2.7.5"
 retrofit = "2.9.0"
 room-ktx = "2.6.1"
 ksp_version = "1.9.0-1.0.13"
+navigationTestingAndroid = "2.9.5"
+espressoContrib = "3.7.0"
 
 [libraries]
 androidx-espresso-core = { module = "androidx.test.espresso:espresso-core", version.ref = "espresso-core" }
@@ -38,6 +40,8 @@ junit = { module = "junit:junit", version.ref = "junit" }
 logging-interceptor = { module = "com.squareup.okhttp3:logging-interceptor", version.ref = "logging-interceptor" }
 material = { module = "com.google.android.material:material", version.ref = "material" }
 retrofit = { module = "com.squareup.retrofit2:retrofit", version.ref = "retrofit" }
+androidx-navigation-testing-android = { group = "androidx.navigation", name = "navigation-testing-android", version.ref = "navigationTestingAndroid" }
+androidx-espresso-contrib = { group = "androidx.test.espresso", name = "espresso-contrib", version.ref = "espressoContrib" }
 
 [plugins]
 android-application = { id = "com.android.application", version.ref = "android-gradle-plugin" }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index ab04d71..5b55291 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 #Fri Nov 10 11:07:54 CET 2023
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.0-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
